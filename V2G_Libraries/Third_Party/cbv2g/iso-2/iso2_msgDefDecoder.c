/* SPDX-License-Identifier: Apache-2.0 */
/*
 * Copyright (C) 2022 - 2023 chargebyte GmbH
 * Copyright (C) 2022 - 2023 Contributors to EVerest
 */

/*****************************************************
 *
 * @author
 * @version
 *
 * The Code is generated! Changes may be overwritten.
 *
 *****************************************************/

/**
  * @file iso2_msgDefDecoder.c
  * @brief Description goes here
  *
  **/
#include <inttypes.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "exi_basetypes.h"
#include "exi_basetypes_decoder.h"
#include "exi_error_codes.h"
#include "exi_header.h"
#include "exi_types_decoder.h"
#include "iso2_msgDefDatatypes.h"
#include "iso2_msgDefDecoder.h"



static int decode_iso2_CostType(exi_bitstream_t* stream, struct iso2_CostType* CostType, char* xmlOut);
static int decode_iso2_TransformType(exi_bitstream_t* stream, struct iso2_TransformType* TransformType, char* xmlOut);
static int decode_iso2_IntervalType(exi_bitstream_t* stream, struct iso2_IntervalType* IntervalType, char* xmlOut);
static int decode_iso2_TransformsType(exi_bitstream_t* stream, struct iso2_TransformsType* TransformsType, char* xmlOut);
static int decode_iso2_DSAKeyValueType(exi_bitstream_t* stream, struct iso2_DSAKeyValueType* DSAKeyValueType, char* xmlOut);
static int decode_iso2_X509IssuerSerialType(exi_bitstream_t* stream, struct iso2_X509IssuerSerialType* X509IssuerSerialType, char* xmlOut);
static int decode_iso2_RelativeTimeIntervalType(exi_bitstream_t* stream, struct iso2_RelativeTimeIntervalType* RelativeTimeIntervalType, char* xmlOut);
static int decode_iso2_DigestMethodType(exi_bitstream_t* stream, struct iso2_DigestMethodType* DigestMethodType, char* xmlOut);
static int decode_iso2_RSAKeyValueType(exi_bitstream_t* stream, struct iso2_RSAKeyValueType* RSAKeyValueType, char* xmlOut);
static int decode_iso2_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso2_CanonicalizationMethodType* CanonicalizationMethodType, char* xmlOut);
static int decode_iso2_SignatureMethodType(exi_bitstream_t* stream, struct iso2_SignatureMethodType* SignatureMethodType, char* xmlOut);
static int decode_iso2_KeyValueType(exi_bitstream_t* stream, struct iso2_KeyValueType* KeyValueType, char* xmlOut);
static int decode_iso2_ReferenceType(exi_bitstream_t* stream, struct iso2_ReferenceType* ReferenceType, char* xmlOut);
static int decode_iso2_RetrievalMethodType(exi_bitstream_t* stream, struct iso2_RetrievalMethodType* RetrievalMethodType, char* xmlOut);
static int decode_iso2_X509DataType(exi_bitstream_t* stream, struct iso2_X509DataType* X509DataType, char* xmlOut);
static int decode_iso2_PGPDataType(exi_bitstream_t* stream, struct iso2_PGPDataType* PGPDataType, char* xmlOut);
static int decode_iso2_SPKIDataType(exi_bitstream_t* stream, struct iso2_SPKIDataType* SPKIDataType, char* xmlOut);
static int decode_iso2_SignedInfoType(exi_bitstream_t* stream, struct iso2_SignedInfoType* SignedInfoType, char* xmlOut);
static int decode_iso2_DC_EVStatusType(exi_bitstream_t* stream, struct iso2_DC_EVStatusType* DC_EVStatusType, char* xmlOut);
static int decode_iso2_SelectedServiceType(exi_bitstream_t* stream, struct iso2_SelectedServiceType* SelectedServiceType, char* xmlOut);
static int decode_iso2_ServiceType(exi_bitstream_t* stream, struct iso2_ServiceType* ServiceType, char* xmlOut);
static int decode_iso2_SignatureValueType(exi_bitstream_t* stream, struct iso2_SignatureValueType* SignatureValueType, char* xmlOut);
static int decode_iso2_SubCertificatesType(exi_bitstream_t* stream, struct iso2_SubCertificatesType* SubCertificatesType, char* xmlOut);
static int decode_iso2_KeyInfoType(exi_bitstream_t* stream, struct iso2_KeyInfoType* KeyInfoType, char* xmlOut);
static int decode_iso2_ObjectType(exi_bitstream_t* stream, struct iso2_ObjectType* ObjectType, char* xmlOut);
static int decode_iso2_SupportedEnergyTransferModeType(exi_bitstream_t* stream, struct iso2_SupportedEnergyTransferModeType* SupportedEnergyTransferModeType, char* xmlOut);
static int decode_iso2_CertificateChainType(exi_bitstream_t* stream, struct iso2_CertificateChainType* CertificateChainType, char* xmlOut);
static int decode_iso2_BodyBaseType(exi_bitstream_t* stream, struct iso2_BodyBaseType* BodyBaseType, char* xmlOut);
static int decode_iso2_NotificationType(exi_bitstream_t* stream, struct iso2_NotificationType* NotificationType, char* xmlOut);
static int decode_iso2_DC_EVSEStatusType(exi_bitstream_t* stream, struct iso2_DC_EVSEStatusType* DC_EVSEStatusType, char* xmlOut);
static int decode_iso2_AC_EVSEStatusType(exi_bitstream_t* stream, struct iso2_AC_EVSEStatusType* AC_EVSEStatusType, char* xmlOut);
static int decode_iso2_EVSEStatusType(exi_bitstream_t* stream, struct iso2_EVSEStatusType* EVSEStatusType, char* xmlOut);
static int decode_iso2_SelectedServiceListType(exi_bitstream_t* stream, struct iso2_SelectedServiceListType* SelectedServiceListType, char* xmlOut);
static int decode_iso2_PaymentOptionListType(exi_bitstream_t* stream, struct iso2_PaymentOptionListType* PaymentOptionListType, char* xmlOut);
static int decode_iso2_SignatureType(exi_bitstream_t* stream, struct iso2_SignatureType* SignatureType, char* xmlOut);
static int decode_iso2_ListOfRootCertificateIDsType(exi_bitstream_t* stream, struct iso2_ListOfRootCertificateIDsType* ListOfRootCertificateIDsType, char* xmlOut);
static int decode_iso2_PhysicalValueType(exi_bitstream_t* stream, struct iso2_PhysicalValueType* PhysicalValueType, char* xmlOut);
static int decode_iso2_ConsumptionCostType(exi_bitstream_t* stream, struct iso2_ConsumptionCostType* ConsumptionCostType, char* xmlOut);
static int decode_iso2_PMaxScheduleEntryType(exi_bitstream_t* stream, struct iso2_PMaxScheduleEntryType* PMaxScheduleEntryType, char* xmlOut);
static int decode_iso2_SalesTariffEntryType(exi_bitstream_t* stream, struct iso2_SalesTariffEntryType* SalesTariffEntryType, char* xmlOut);
static int decode_iso2_PMaxScheduleType(exi_bitstream_t* stream, struct iso2_PMaxScheduleType* PMaxScheduleType, char* xmlOut);
static int decode_iso2_ParameterType(exi_bitstream_t* stream, struct iso2_ParameterType* ParameterType, char* xmlOut);
static int decode_iso2_SalesTariffType(exi_bitstream_t* stream, struct iso2_SalesTariffType* SalesTariffType, char* xmlOut);
static int decode_iso2_ProfileEntryType(exi_bitstream_t* stream, struct iso2_ProfileEntryType* ProfileEntryType, char* xmlOut);
static int decode_iso2_SAScheduleTupleType(exi_bitstream_t* stream, struct iso2_SAScheduleTupleType* SAScheduleTupleType, char* xmlOut);
static int decode_iso2_ParameterSetType(exi_bitstream_t* stream, struct iso2_ParameterSetType* ParameterSetType, char* xmlOut);
static int decode_iso2_ChargingProfileType(exi_bitstream_t* stream, struct iso2_ChargingProfileType* ChargingProfileType, char* xmlOut);
static int decode_iso2_MeterInfoType(exi_bitstream_t* stream, struct iso2_MeterInfoType* MeterInfoType, char* xmlOut);
static int decode_iso2_AC_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_AC_EVChargeParameterType* AC_EVChargeParameterType, char* xmlOut);
static int decode_iso2_DC_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_DC_EVChargeParameterType* DC_EVChargeParameterType, char* xmlOut);
static int decode_iso2_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_EVChargeParameterType* EVChargeParameterType, char* xmlOut);
static int decode_iso2_SASchedulesType(exi_bitstream_t* stream, struct iso2_SASchedulesType* SASchedulesType, char* xmlOut);
static int decode_iso2_SAScheduleListType(exi_bitstream_t* stream, struct iso2_SAScheduleListType* SAScheduleListType, char* xmlOut);
static int decode_iso2_ServiceParameterListType(exi_bitstream_t* stream, struct iso2_ServiceParameterListType* ServiceParameterListType, char* xmlOut);
static int decode_iso2_ChargeServiceType(exi_bitstream_t* stream, struct iso2_ChargeServiceType* ChargeServiceType, char* xmlOut);
static int decode_iso2_ContractSignatureEncryptedPrivateKeyType(exi_bitstream_t* stream, struct iso2_ContractSignatureEncryptedPrivateKeyType* ContractSignatureEncryptedPrivateKeyType, char* xmlOut);
static int decode_iso2_EVPowerDeliveryParameterType(exi_bitstream_t* stream, struct iso2_EVPowerDeliveryParameterType* EVPowerDeliveryParameterType, char* xmlOut);
static int decode_iso2_DC_EVPowerDeliveryParameterType(exi_bitstream_t* stream, struct iso2_DC_EVPowerDeliveryParameterType* DC_EVPowerDeliveryParameterType, char* xmlOut);
static int decode_iso2_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_EVSEChargeParameterType* EVSEChargeParameterType, char* xmlOut);
static int decode_iso2_AC_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_AC_EVSEChargeParameterType* AC_EVSEChargeParameterType, char* xmlOut);
static int decode_iso2_DC_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_DC_EVSEChargeParameterType* DC_EVSEChargeParameterType, char* xmlOut);
static int decode_iso2_ServiceListType(exi_bitstream_t* stream, struct iso2_ServiceListType* ServiceListType, char* xmlOut);
static int decode_iso2_DiffieHellmanPublickeyType(exi_bitstream_t* stream, struct iso2_DiffieHellmanPublickeyType* DiffieHellmanPublickeyType, char* xmlOut);
static int decode_iso2_EMAIDType(exi_bitstream_t* stream, struct iso2_EMAIDType* EMAIDType, char* xmlOut);
static int decode_iso2_MessageHeaderType(exi_bitstream_t* stream, struct iso2_MessageHeaderType* MessageHeaderType, char* xmlOut);
static int decode_iso2_CertificateUpdateReqType(exi_bitstream_t* stream, struct iso2_CertificateUpdateReqType* CertificateUpdateReqType, char* xmlOut);
static int decode_iso2_ServiceDetailReqType(exi_bitstream_t* stream, struct iso2_ServiceDetailReqType* ServiceDetailReqType, char* xmlOut);
static int decode_iso2_WeldingDetectionResType(exi_bitstream_t* stream, struct iso2_WeldingDetectionResType* WeldingDetectionResType, char* xmlOut);
static int decode_iso2_AuthorizationReqType(exi_bitstream_t* stream, struct iso2_AuthorizationReqType* AuthorizationReqType, char* xmlOut);
static int decode_iso2_PaymentDetailsResType(exi_bitstream_t* stream, struct iso2_PaymentDetailsResType* PaymentDetailsResType, char* xmlOut);
static int decode_iso2_SessionStopReqType(exi_bitstream_t* stream, struct iso2_SessionStopReqType* SessionStopReqType, char* xmlOut);
static int decode_iso2_CertificateUpdateResType(exi_bitstream_t* stream, struct iso2_CertificateUpdateResType* CertificateUpdateResType, char* xmlOut);
static int decode_iso2_CertificateInstallationResType(exi_bitstream_t* stream, struct iso2_CertificateInstallationResType* CertificateInstallationResType, char* xmlOut);
static int decode_iso2_CableCheckResType(exi_bitstream_t* stream, struct iso2_CableCheckResType* CableCheckResType, char* xmlOut);
static int decode_iso2_PowerDeliveryReqType(exi_bitstream_t* stream, struct iso2_PowerDeliveryReqType* PowerDeliveryReqType, char* xmlOut);
static int decode_iso2_CertificateInstallationReqType(exi_bitstream_t* stream, struct iso2_CertificateInstallationReqType* CertificateInstallationReqType, char* xmlOut);
static int decode_iso2_MeteringReceiptReqType(exi_bitstream_t* stream, struct iso2_MeteringReceiptReqType* MeteringReceiptReqType, char* xmlOut);
static int decode_iso2_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, struct iso2_ChargeParameterDiscoveryReqType* ChargeParameterDiscoveryReqType, char* xmlOut);
static int decode_iso2_SessionSetupResType(exi_bitstream_t* stream, struct iso2_SessionSetupResType* SessionSetupResType, char* xmlOut);
static int decode_iso2_SessionSetupReqType(exi_bitstream_t* stream, struct iso2_SessionSetupReqType* SessionSetupReqType, char* xmlOut);
static int decode_iso2_SessionStopResType(exi_bitstream_t* stream, struct iso2_SessionStopResType* SessionStopResType, char* xmlOut);
static int decode_iso2_PowerDeliveryResType(exi_bitstream_t* stream, struct iso2_PowerDeliveryResType* PowerDeliveryResType, char* xmlOut);
static int decode_iso2_CurrentDemandResType(exi_bitstream_t* stream, struct iso2_CurrentDemandResType* CurrentDemandResType, char* xmlOut);
static int decode_iso2_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, struct iso2_ChargeParameterDiscoveryResType* ChargeParameterDiscoveryResType, char* xmlOut);
static int decode_iso2_ChargingStatusResType(exi_bitstream_t* stream, struct iso2_ChargingStatusResType* ChargingStatusResType, char* xmlOut);
static int decode_iso2_ServiceDiscoveryReqType(exi_bitstream_t* stream, struct iso2_ServiceDiscoveryReqType* ServiceDiscoveryReqType, char* xmlOut);
static int decode_iso2_PaymentDetailsReqType(exi_bitstream_t* stream, struct iso2_PaymentDetailsReqType* PaymentDetailsReqType, char* xmlOut);
static int decode_iso2_PaymentServiceSelectionReqType(exi_bitstream_t* stream, struct iso2_PaymentServiceSelectionReqType* PaymentServiceSelectionReqType, char* xmlOut);
static int decode_iso2_ServiceDetailResType(exi_bitstream_t* stream, struct iso2_ServiceDetailResType* ServiceDetailResType, char* xmlOut);
static int decode_iso2_PreChargeResType(exi_bitstream_t* stream, struct iso2_PreChargeResType* PreChargeResType, char* xmlOut);
static int decode_iso2_ServiceDiscoveryResType(exi_bitstream_t* stream, struct iso2_ServiceDiscoveryResType* ServiceDiscoveryResType, char* xmlOut);
static int decode_iso2_CableCheckReqType(exi_bitstream_t* stream, struct iso2_CableCheckReqType* CableCheckReqType, char* xmlOut);
static int decode_iso2_MeteringReceiptResType(exi_bitstream_t* stream, struct iso2_MeteringReceiptResType* MeteringReceiptResType, char* xmlOut);
static int decode_iso2_AuthorizationResType(exi_bitstream_t* stream, struct iso2_AuthorizationResType* AuthorizationResType, char* xmlOut);
static int decode_iso2_CurrentDemandReqType(exi_bitstream_t* stream, struct iso2_CurrentDemandReqType* CurrentDemandReqType, char* xmlOut);
static int decode_iso2_PaymentServiceSelectionResType(exi_bitstream_t* stream, struct iso2_PaymentServiceSelectionResType* PaymentServiceSelectionResType, char* xmlOut);
static int decode_iso2_ChargingStatusReqType(exi_bitstream_t* stream, struct iso2_ChargingStatusReqType* ChargingStatusReqType, char* xmlOut);
static int decode_iso2_WeldingDetectionReqType(exi_bitstream_t* stream, struct iso2_WeldingDetectionReqType* WeldingDetectionReqType, char* xmlOut);
static int decode_iso2_PreChargeReqType(exi_bitstream_t* stream, struct iso2_PreChargeReqType* PreChargeReqType, char* xmlOut);
static int decode_iso2_BodyType(exi_bitstream_t* stream, struct iso2_BodyType* BodyType, char* xmlOut);
static int decode_iso2_V2G_Message(exi_bitstream_t* stream, struct iso2_V2G_Message* V2G_Message, char* xmlOut);

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}Cost; type={urn:iso:15118:2:2013:MsgDataTypes}CostType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: costKind, costKindType (1, 1); amount, unsignedInt (1, 1); amountMultiplier, unitMultiplierType (0, 1);
static int decode_iso2_CostType(exi_bitstream_t* stream, struct iso2_CostType* CostType, char* xmlOut) {
    int grammar_id = 0;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CostType(CostType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 0:
            // Grammar: ID=0; read/write bits=1; START (costKind)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (costKind, costKindType (string)); next=1

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}costKind");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}costKind");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                CostType->costKind = (iso2_costKindType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_costKindType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 1;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}costKind>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 1:
            // Grammar: ID=1; read/write bits=1; START (amount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (amount, unsignedInt (unsignedLong)); next=2

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}amount");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}amount");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &CostType->amount);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", CostType->amount);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}amount>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=2; START (amountMultiplier), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (amountMultiplier, unitMultiplierType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}amountMultiplier");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}amountMultiplier");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                // type has min_value = -3
                                CostType->amountMultiplier = (int8_t)(value + -3);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", CostType->amountMultiplier);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                CostType->amountMultiplier_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}amountMultiplier>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transform; type={http://www.w3.org/2000/09/xmldsig#}TransformType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1); XPath, string (0, 1);
static int decode_iso2_TransformType(exi_bitstream_t* stream, struct iso2_TransformType* TransformType, char* xmlOut) {
    int grammar_id = 5;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_TransformType(TransformType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 5:
            // Grammar: ID=5; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=6

                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &TransformType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (TransformType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            TransformType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, TransformType->Algorithm.charactersLen, TransformType->Algorithm.characters, iso2_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < TransformType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(TransformType->Algorithm.characters[i]))
                                {
                                    TransformType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, TransformType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 6;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 6:
            // Grammar: ID=6; read/write bits=3; START (XPath), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (XPath, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}XPath");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}XPath");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &TransformType->XPath.charactersLen);
                            if (error == 0)
                            {
                                if (TransformType->XPath.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    TransformType->XPath.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, TransformType->XPath.charactersLen, TransformType->XPath.characters, iso2_XPath_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < TransformType->XPath.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(TransformType->XPath.characters[i]))
                                        {
                                            TransformType->XPath.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, TransformType->XPath.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                TransformType->XPath_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}XPath>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &TransformType->ANY.bytesLen, &TransformType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((TransformType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < TransformType->ANY.bytesLen;) {
                            uint32_t octet_a = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[TransformType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        TransformType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}TimeInterval; type={urn:iso:15118:2:2013:MsgDataTypes}IntervalType; base type=; content type=empty;
//          abstract=True; final=False;
static int decode_iso2_IntervalType(exi_bitstream_t* stream, struct iso2_IntervalType* IntervalType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)IntervalType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transforms; type={http://www.w3.org/2000/09/xmldsig#}TransformsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Transform, TransformType (1, 1);
static int decode_iso2_TransformsType(exi_bitstream_t* stream, struct iso2_TransformsType* TransformsType, char* xmlOut) {
    int grammar_id = 7;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_TransformsType(TransformsType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 7:
            // Grammar: ID=7; read/write bits=1; START (Transform)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Transform, TransformType (TransformType)); next=8

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    // decode: element
                    error = decode_iso2_TransformType(stream, &TransformsType->Transform, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 8;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transform>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 8:
            // Grammar: ID=8; read/write bits=2; START (Transform), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Transform, TransformType (TransformType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    // decode: element
                    error = decode_iso2_TransformType(stream, &TransformsType->Transform, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transform>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}DSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: P, CryptoBinary (0, 1)(was 1, 1)(seq. ['P', 'Q']); Q, CryptoBinary (0, 1)(was 1, 1)(seq. ['P', 'Q']); G, CryptoBinary (0, 1); Y, CryptoBinary (1, 1); J, CryptoBinary (0, 1); Seed, CryptoBinary (0, 1)(was 1, 1)(seq. ['Seed', 'PgenCounter']); PgenCounter, CryptoBinary (0, 1)(was 1, 1)(seq. ['Seed', 'PgenCounter']);
static int decode_iso2_DSAKeyValueType(exi_bitstream_t* stream, struct iso2_DSAKeyValueType* DSAKeyValueType, char* xmlOut) {
    int grammar_id = 9;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DSAKeyValueType(DSAKeyValueType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 9:
            // Grammar: ID=9; read/write bits=2; START (P), START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (P, CryptoBinary (base64Binary)); next=10

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}P");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}P");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->P.bytesLen, &DSAKeyValueType->P.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->P.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->P.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->P.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->P_isUsed = 1u;
                        grammar_id = 10;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}P>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (G, CryptoBinary (base64Binary)); next=12

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}G");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}G");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->G.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->G.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->G.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 12;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}G>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=13

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 13;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 10:
            // Grammar: ID=10; read/write bits=1; START (Q)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Q, CryptoBinary (base64Binary)); next=11

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Q");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Q");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Q.bytesLen, &DSAKeyValueType->Q.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Q.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Q.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Q.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Q_isUsed = 1u;
                        grammar_id = 11;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Q>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 11:
            // Grammar: ID=11; read/write bits=2; START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (G, CryptoBinary (base64Binary)); next=12

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}G");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}G");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->G.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->G.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->G.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 12;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}G>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=13

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 13;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 12:
            // Grammar: ID=12; read/write bits=1; START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=13

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 13;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 13:
            // Grammar: ID=13; read/write bits=2; START (J), START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (J, CryptoBinary (base64Binary)); next=14

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}J");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}J");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->J.bytesLen, &DSAKeyValueType->J.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->J.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->J.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->J.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->J_isUsed = 1u;
                        grammar_id = 14;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}J>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=15

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Seed.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Seed.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Seed.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 15;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Seed>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 14:
            // Grammar: ID=14; read/write bits=2; START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=15

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Seed.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Seed.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Seed.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 15;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Seed>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 15:
            // Grammar: ID=15; read/write bits=2; START (PgenCounter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PgenCounter, CryptoBinary (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PgenCounter");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PgenCounter");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->PgenCounter.bytesLen, &DSAKeyValueType->PgenCounter.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->PgenCounter.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->PgenCounter.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->PgenCounter.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->PgenCounter_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PgenCounter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial; type={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerialType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerName, string (1, 1); X509SerialNumber, integer (1, 1);
static int decode_iso2_X509IssuerSerialType(exi_bitstream_t* stream, struct iso2_X509IssuerSerialType* X509IssuerSerialType, char* xmlOut) {
    int grammar_id = 16;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_X509IssuerSerialType(X509IssuerSerialType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 16:
            // Grammar: ID=16; read/write bits=1; START (X509IssuerName)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (X509IssuerName, string (string)); next=17

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509IssuerName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509IssuerName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509IssuerSerialType->X509IssuerName.charactersLen);
                            if (error == 0)
                            {
                                if (X509IssuerSerialType->X509IssuerName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509IssuerSerialType->X509IssuerName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509IssuerSerialType->X509IssuerName.charactersLen, X509IssuerSerialType->X509IssuerName.characters, iso2_X509IssuerName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < X509IssuerSerialType->X509IssuerName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(X509IssuerSerialType->X509IssuerName.characters[i]))
                                        {
                                            X509IssuerSerialType->X509IssuerName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, X509IssuerSerialType->X509IssuerName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 17;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509IssuerName>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 17:
            // Grammar: ID=17; read/write bits=1; START (X509SerialNumber)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (X509SerialNumber, integer (decimal)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber");
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &X509IssuerSerialType->X509SerialNumber);
                        if (error == 0)
                        {
                            uint8_t realInteger[21] = {0}; // max length: 20 + 1 zero terminator
                            size_t realInteger_size = 0;
                            int result = exi_basetypes_convert_bytes_from_unsigned(&(X509IssuerSerialType->X509SerialNumber.data), &realInteger[0], &realInteger_size, 21);
                            if (result == 0)
                            {
                                // reverse array
                                uint8_t temp;
                                uint8_t start = 0;
                                uint8_t end = realInteger_size - 1;
                                while (start < end) {
                                    temp = realInteger[start];
                                    realInteger[start] = realInteger[end];
                                    realInteger[end] = temp;
                                    start++;
                                    end--;
                                }
                                char asHex[128] = "";
                                char* ahPtr = &asHex[0];
                                uint8_t* contentPtr = &realInteger[0];
                                if(realInteger_size * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                                while(realInteger_size--) {
                                  sprintf(ahPtr, "%02X", *contentPtr);
                                  ahPtr += 2;
                                  ++contentPtr;
                                }
                                *ahPtr = 0;
                                strcat(xmlOut, ">0x");
                                strcat(xmlOut, asHex);
                            }
                            else
                            {
                                strcat(xmlOut, ">ERROR");
                            }
                            grammar_id = 3;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval; type={urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeIntervalType; base type=IntervalType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: start, AnonType (1, 1); duration, AnonType (0, 1);
static int decode_iso2_RelativeTimeIntervalType(exi_bitstream_t* stream, struct iso2_RelativeTimeIntervalType* RelativeTimeIntervalType, char* xmlOut) {
    int grammar_id = 18;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_RelativeTimeIntervalType(RelativeTimeIntervalType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 18:
            // Grammar: ID=18; read/write bits=1; START (start)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (start, AnonType (unsignedInt)); next=19

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}start");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}start");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &RelativeTimeIntervalType->start);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", RelativeTimeIntervalType->start);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 19;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}start>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 19:
            // Grammar: ID=19; read/write bits=2; START (duration), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (duration, AnonType (unsignedInt)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}duration");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &RelativeTimeIntervalType->duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", RelativeTimeIntervalType->duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        RelativeTimeIntervalType->duration_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}duration>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DigestMethod; type={http://www.w3.org/2000/09/xmldsig#}DigestMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso2_DigestMethodType(exi_bitstream_t* stream, struct iso2_DigestMethodType* DigestMethodType, char* xmlOut) {
    int grammar_id = 20;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DigestMethodType(DigestMethodType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 20:
            // Grammar: ID=20; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=21

                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &DigestMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (DigestMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            DigestMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, DigestMethodType->Algorithm.charactersLen, DigestMethodType->Algorithm.characters, iso2_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < DigestMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(DigestMethodType->Algorithm.characters[i]))
                                {
                                    DigestMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, DigestMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 21;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 21:
            // Grammar: ID=21; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DigestMethodType->ANY.bytesLen, &DigestMethodType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DigestMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DigestMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DigestMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DigestMethodType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}RSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Modulus, CryptoBinary (1, 1); Exponent, CryptoBinary (1, 1);
static int decode_iso2_RSAKeyValueType(exi_bitstream_t* stream, struct iso2_RSAKeyValueType* RSAKeyValueType, char* xmlOut) {
    int grammar_id = 22;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_RSAKeyValueType(RSAKeyValueType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 22:
            // Grammar: ID=22; read/write bits=1; START (Modulus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Modulus, CryptoBinary (base64Binary)); next=23

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Modulus");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Modulus");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Modulus.bytesLen, &RSAKeyValueType->Modulus.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((RSAKeyValueType->Modulus.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < RSAKeyValueType->Modulus.bytesLen;) {
                            uint32_t octet_a = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            uint32_t octet_b = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            uint32_t octet_c = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[RSAKeyValueType->Modulus.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 23;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Modulus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 23:
            // Grammar: ID=23; read/write bits=1; START (Exponent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Exponent, CryptoBinary (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Exponent");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Exponent");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Exponent.bytesLen, &RSAKeyValueType->Exponent.bytes[0], iso2_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((RSAKeyValueType->Exponent.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < RSAKeyValueType->Exponent.bytesLen;) {
                            uint32_t octet_a = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            uint32_t octet_b = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            uint32_t octet_c = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[RSAKeyValueType->Exponent.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Exponent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod; type={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso2_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso2_CanonicalizationMethodType* CanonicalizationMethodType, char* xmlOut) {
    int grammar_id = 24;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CanonicalizationMethodType(CanonicalizationMethodType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 24:
            // Grammar: ID=24; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=25

                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CanonicalizationMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (CanonicalizationMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CanonicalizationMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CanonicalizationMethodType->Algorithm.charactersLen, CanonicalizationMethodType->Algorithm.characters, iso2_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < CanonicalizationMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(CanonicalizationMethodType->Algorithm.characters[i]))
                                {
                                    CanonicalizationMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, CanonicalizationMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 25;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 25:
            // Grammar: ID=25; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CanonicalizationMethodType->ANY.bytesLen, &CanonicalizationMethodType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CanonicalizationMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CanonicalizationMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CanonicalizationMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        CanonicalizationMethodType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureMethod; type={http://www.w3.org/2000/09/xmldsig#}SignatureMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); HMACOutputLength, HMACOutputLengthType (0, 1); ANY, anyType (0, 1);
static int decode_iso2_SignatureMethodType(exi_bitstream_t* stream, struct iso2_SignatureMethodType* SignatureMethodType, char* xmlOut) {
    int grammar_id = 26;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SignatureMethodType(SignatureMethodType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 26:
            // Grammar: ID=26; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=27

                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureMethodType->Algorithm.charactersLen, SignatureMethodType->Algorithm.characters, iso2_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < SignatureMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureMethodType->Algorithm.characters[i]))
                                {
                                    SignatureMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 27;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 27:
            // Grammar: ID=27; read/write bits=3; START (HMACOutputLength), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (HMACOutputLength, HMACOutputLengthType (integer)); next=28

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength");
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &SignatureMethodType->HMACOutputLength);
                        if (error == 0)
                        {
                            uint8_t realInteger[21] = {0}; // max length: 20 + 1 zero terminator
                            size_t realInteger_size = 0;
                            int result = exi_basetypes_convert_bytes_from_unsigned(&(SignatureMethodType->HMACOutputLength.data), &realInteger[0], &realInteger_size, 21);
                            if (result == 0)
                            {
                                // reverse array
                                uint8_t temp;
                                uint8_t start = 0;
                                uint8_t end = realInteger_size - 1;
                                while (start < end) {
                                    temp = realInteger[start];
                                    realInteger[start] = realInteger[end];
                                    realInteger[end] = temp;
                                    start++;
                                    end--;
                                }
                                char asHex[128] = "";
                                char* ahPtr = &asHex[0];
                                uint8_t* contentPtr = &realInteger[0];
                                if(realInteger_size * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                                while(realInteger_size--) {
                                  sprintf(ahPtr, "%02X", *contentPtr);
                                  ahPtr += 2;
                                  ++contentPtr;
                                }
                                *ahPtr = 0;
                                strcat(xmlOut, ">0x");
                                strcat(xmlOut, asHex);
                            }
                            else
                            {
                                strcat(xmlOut, ">ERROR");
                            }
                            SignatureMethodType->HMACOutputLength_isUsed = 1u;
                            grammar_id = 28;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 28:
            // Grammar: ID=28; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyValue; type={http://www.w3.org/2000/09/xmldsig#}KeyValueType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: DSAKeyValue, DSAKeyValueType (0, 1); RSAKeyValue, RSAKeyValueType (0, 1); ANY, anyType (0, 1);
static int decode_iso2_KeyValueType(exi_bitstream_t* stream, struct iso2_KeyValueType* KeyValueType, char* xmlOut) {
    int grammar_id = 29;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_KeyValueType(KeyValueType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 29:
            // Grammar: ID=29; read/write bits=2; START (DSAKeyValue), START (RSAKeyValue), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DSAKeyValue, DSAKeyValueType (DSAKeyValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue");
                    // decode: element
                    error = decode_iso2_DSAKeyValueType(stream, &KeyValueType->DSAKeyValue, xmlOut);
                    if (error == 0)
                    {
                        KeyValueType->DSAKeyValue_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (RSAKeyValue, RSAKeyValueType (RSAKeyValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue");
                    // decode: element
                    error = decode_iso2_RSAKeyValueType(stream, &KeyValueType->RSAKeyValue, xmlOut);
                    if (error == 0)
                    {
                        KeyValueType->RSAKeyValue_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyValueType->ANY.bytesLen, &KeyValueType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyValueType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyValueType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyValueType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyValueType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Reference; type={http://www.w3.org/2000/09/xmldsig#}ReferenceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1); DigestMethod, DigestMethodType (1, 1); DigestValue, DigestValueType (1, 1);
static int decode_iso2_ReferenceType(exi_bitstream_t* stream, struct iso2_ReferenceType* ReferenceType, char* xmlOut) {
    int grammar_id = 30;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ReferenceType(ReferenceType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 30:
            // Grammar: ID=30; read/write bits=3; START (Id), START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=31

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Id.charactersLen, ReferenceType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Id.characters[i]))
                                {
                                    ReferenceType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Id_isUsed = 1u;
                    grammar_id = 31;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=32

                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso2_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Type.characters[i]))
                                {
                                    ReferenceType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 32;

                    }
                    break;
                case 2:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=33

                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso2_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 33;

                    }
                    break;
                case 3:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=34

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &ReferenceType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 34;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=35

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso2_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 35;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 31:
            // Grammar: ID=31; read/write bits=3; START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=32

                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso2_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Type.characters[i]))
                                {
                                    ReferenceType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 32;

                    }
                    break;
                case 1:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=33

                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso2_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 33;

                    }
                    break;
                case 2:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=34

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &ReferenceType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 34;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=35

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso2_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 35;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 32:
            // Grammar: ID=32; read/write bits=2; START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=33

                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso2_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 33;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=34

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &ReferenceType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 34;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=35

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso2_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 35;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 33:
            // Grammar: ID=33; read/write bits=2; START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=34

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &ReferenceType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 34;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=35

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso2_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 35;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 34:
            // Grammar: ID=34; read/write bits=1; START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=35

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso2_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 35;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 35:
            // Grammar: ID=35; read/write bits=1; START (DigestValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DigestValue, DigestValueType (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestValue");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ReferenceType->DigestValue.bytesLen, &ReferenceType->DigestValue.bytes[0], iso2_DigestValueType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ReferenceType->DigestValue.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ReferenceType->DigestValue.bytesLen;) {
                            uint32_t octet_a = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            uint32_t octet_b = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            uint32_t octet_c = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ReferenceType->DigestValue.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RetrievalMethod; type={http://www.w3.org/2000/09/xmldsig#}RetrievalMethodType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1);
static int decode_iso2_RetrievalMethodType(exi_bitstream_t* stream, struct iso2_RetrievalMethodType* RetrievalMethodType, char* xmlOut) {
    int grammar_id = 36;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_RetrievalMethodType(RetrievalMethodType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 36:
            // Grammar: ID=36; read/write bits=3; START (Type), START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=37

                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->Type.charactersLen, RetrievalMethodType->Type.characters, iso2_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < RetrievalMethodType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->Type.characters[i]))
                                {
                                    RetrievalMethodType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->Type_isUsed = 1u;
                    grammar_id = 37;

                    }
                    break;
                case 1:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=38

                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso2_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < RetrievalMethodType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->URI.characters[i]))
                                {
                                    RetrievalMethodType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 38;

                    }
                    break;
                case 2:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 37:
            // Grammar: ID=37; read/write bits=2; START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=38

                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso2_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < RetrievalMethodType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->URI.characters[i]))
                                {
                                    RetrievalMethodType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 38;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 38:
            // Grammar: ID=38; read/write bits=2; START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso2_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509Data; type={http://www.w3.org/2000/09/xmldsig#}X509DataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerSerial, X509IssuerSerialType (0, 1); X509SKI, base64Binary (0, 1); X509SubjectName, string (0, 1); X509Certificate, base64Binary (0, 1); X509CRL, base64Binary (0, 1); ANY, anyType (0, 1);
static int decode_iso2_X509DataType(exi_bitstream_t* stream, struct iso2_X509DataType* X509DataType, char* xmlOut) {
    int grammar_id = 39;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_X509DataType(X509DataType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 39:
            // Grammar: ID=39; read/write bits=3; START (X509IssuerSerial), START (X509SKI), START (X509SubjectName), START (X509Certificate), START (X509CRL), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (X509IssuerSerial, X509IssuerSerialType (X509IssuerSerialType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial");
                    // decode: element
                    error = decode_iso2_X509IssuerSerialType(stream, &X509DataType->X509IssuerSerial, xmlOut);
                    if (error == 0)
                    {
                        X509DataType->X509IssuerSerial_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (X509SKI, base64Binary (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SKI");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SKI");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509SKI.bytesLen, &X509DataType->X509SKI.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509SKI.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509SKI.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509SKI.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509SKI_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SKI>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (X509SubjectName, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SubjectName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SubjectName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509DataType->X509SubjectName.charactersLen);
                            if (error == 0)
                            {
                                if (X509DataType->X509SubjectName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509DataType->X509SubjectName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509DataType->X509SubjectName.charactersLen, X509DataType->X509SubjectName.characters, iso2_X509SubjectName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < X509DataType->X509SubjectName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(X509DataType->X509SubjectName.characters[i]))
                                        {
                                            X509DataType->X509SubjectName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, X509DataType->X509SubjectName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                X509DataType->X509SubjectName_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SubjectName>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (X509Certificate, base64Binary (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Certificate");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509Certificate.bytesLen, &X509DataType->X509Certificate.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509Certificate.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509Certificate_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Certificate>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (X509CRL, base64Binary (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509CRL");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509CRL");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509CRL.bytesLen, &X509DataType->X509CRL.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509CRL.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509CRL.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509CRL.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509CRL_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509CRL>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->ANY.bytesLen, &X509DataType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->ANY.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}PGPData; type={http://www.w3.org/2000/09/xmldsig#}PGPDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True; sequence=True (2;
// Particle: PGPKeyID, base64Binary (1, 1); PGPKeyPacket, base64Binary (0, 1); ANY, anyType (0, 1); PGPKeyPacket, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso2_PGPDataType(exi_bitstream_t* stream, struct iso2_PGPDataType* PGPDataType, char* xmlOut) {
    int grammar_id = 40;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PGPDataType(PGPDataType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 40:
            // Grammar: ID=40; read/write bits=2; START (PGPKeyID), START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyID, base64Binary (base64Binary)); next=41

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyID");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyID");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyID.bytesLen, &PGPDataType->choice_1.PGPKeyID.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyID.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyID.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyID.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 41;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyID>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=42

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 42;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 41:
            // Grammar: ID=41; read/write bits=3; START (PGPKeyPacket), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=42

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 42;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 43;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 42:
            // Grammar: ID=42; read/write bits=3; START (ANY), END Element, END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 43;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 43:
            // Grammar: ID=43; read/write bits=1; START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=44

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.PGPKeyPacket.bytesLen, &PGPDataType->choice_2.PGPKeyPacket.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_2.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_2.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_2.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 44;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 44:
            // Grammar: ID=44; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=43
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.ANY.bytesLen, &PGPDataType->choice_2.ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_2.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_2.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_2.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_2.ANY_isUsed = 1u;
                        grammar_id = 43;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SPKIData; type={http://www.w3.org/2000/09/xmldsig#}SPKIDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SPKISexp, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso2_SPKIDataType(exi_bitstream_t* stream, struct iso2_SPKIDataType* SPKIDataType, char* xmlOut) {
    int grammar_id = 45;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SPKIDataType(SPKIDataType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 45:
            // Grammar: ID=45; read/write bits=1; START (SPKISexp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SPKISexp, base64Binary (base64Binary)); next=46

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKISexp");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKISexp");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->SPKISexp.bytesLen, &SPKIDataType->SPKISexp.bytes[0], iso2_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SPKIDataType->SPKISexp.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SPKIDataType->SPKISexp.bytesLen;) {
                            uint32_t octet_a = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            uint32_t octet_b = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            uint32_t octet_c = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SPKIDataType->SPKISexp.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 46;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKISexp>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 46:
            // Grammar: ID=46; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->ANY.bytesLen, &SPKIDataType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SPKIDataType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SPKIDataType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SPKIDataType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SPKIDataType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignedInfo; type={http://www.w3.org/2000/09/xmldsig#}SignedInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); CanonicalizationMethod, CanonicalizationMethodType (1, 1); SignatureMethod, SignatureMethodType (1, 1); Reference, ReferenceType (1, 4);
static int decode_iso2_SignedInfoType(exi_bitstream_t* stream, struct iso2_SignedInfoType* SignedInfoType, char* xmlOut) {
    int grammar_id = 47;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SignedInfoType(SignedInfoType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 47:
            // Grammar: ID=47; read/write bits=2; START (Id), START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=48

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedInfoType->Id.charactersLen, SignedInfoType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < SignedInfoType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignedInfoType->Id.characters[i]))
                                {
                                    SignedInfoType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignedInfoType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignedInfoType->Id_isUsed = 1u;
                    grammar_id = 48;

                    }
                    break;
                case 1:
                    {
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=49

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    // decode: element
                    error = decode_iso2_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 49;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 48:
            // Grammar: ID=48; read/write bits=1; START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=49

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    // decode: element
                    error = decode_iso2_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 49;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 49:
            // Grammar: ID=49; read/write bits=1; START (SignatureMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureMethod, SignatureMethodType (SignatureMethodType)); next=50

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureMethod");
                    // decode: element
                    error = decode_iso2_SignatureMethodType(stream, &SignedInfoType->SignatureMethod, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 50;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 50:
            // Grammar: ID=50; read/write bits=1; START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=51

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso2_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso2_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 51;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 51:
            // Grammar: ID=51; read/write bits=2; START (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=52

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso2_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso2_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 52;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 52:
            // Grammar: ID=52; read/write bits=2; START (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=53

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso2_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso2_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 53;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 53:
            // Grammar: ID=53; read/write bits=2; START (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=54

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso2_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso2_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 54;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 54:
            // Grammar: ID=54; read/write bits=2; START (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso2_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso2_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus; type={urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatusType; base type=EVStatusType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVReady, boolean (1, 1); EVErrorCode, DC_EVErrorCodeType (1, 1); EVRESSSOC, percentValueType (1, 1);
static int decode_iso2_DC_EVStatusType(exi_bitstream_t* stream, struct iso2_DC_EVStatusType* DC_EVStatusType, char* xmlOut) {
    int grammar_id = 55;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DC_EVStatusType(DC_EVStatusType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 55:
            // Grammar: ID=55; read/write bits=1; START (EVReady)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVReady, boolean (boolean)); next=56

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVReady");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVReady");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DC_EVStatusType->EVReady = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 56;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVReady>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 56:
            // Grammar: ID=56; read/write bits=1; START (EVErrorCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVErrorCode, DC_EVErrorCodeType (string)); next=57

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVErrorCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVErrorCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DC_EVStatusType->EVErrorCode = (iso2_DC_EVErrorCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_DC_EVErrorCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 57;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVErrorCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 57:
            // Grammar: ID=57; read/write bits=1; START (EVRESSSOC)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVRESSSOC, percentValueType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVRESSSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVRESSSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVStatusType->EVRESSSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVStatusType->EVRESSSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVRESSSOC>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SelectedService; type={urn:iso:15118:2:2013:MsgDataTypes}SelectedServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceID, serviceIDType (1, 1); ParameterSetID, short (0, 1);
static int decode_iso2_SelectedServiceType(exi_bitstream_t* stream, struct iso2_SelectedServiceType* SelectedServiceType, char* xmlOut) {
    int grammar_id = 58;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SelectedServiceType(SelectedServiceType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 58:
            // Grammar: ID=58; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=59

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &SelectedServiceType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", SelectedServiceType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 59;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 59:
            // Grammar: ID=59; read/write bits=2; START (ParameterSetID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSetID, short (int)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &SelectedServiceType->ParameterSetID);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", SelectedServiceType->ParameterSetID);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        SelectedServiceType->ParameterSetID_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}Service; type={urn:iso:15118:2:2013:MsgDataTypes}ServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceID, serviceIDType (1, 1); ServiceName, serviceNameType (0, 1); ServiceCategory, serviceCategoryType (1, 1); ServiceScope, serviceScopeType (0, 1); FreeService, boolean (1, 1);
static int decode_iso2_ServiceType(exi_bitstream_t* stream, struct iso2_ServiceType* ServiceType, char* xmlOut) {
    int grammar_id = 60;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceType(ServiceType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 60:
            // Grammar: ID=60; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=61

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ServiceType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 61;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 61:
            // Grammar: ID=61; read/write bits=2; START (ServiceName), START (ServiceCategory)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceName, serviceNameType (string)); next=62

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceName");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ServiceType->ServiceName.charactersLen);
                            if (error == 0)
                            {
                                if (ServiceType->ServiceName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ServiceType->ServiceName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ServiceType->ServiceName.charactersLen, ServiceType->ServiceName.characters, iso2_ServiceName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ServiceType->ServiceName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ServiceType->ServiceName.characters[i]))
                                        {
                                            ServiceType->ServiceName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ServiceType->ServiceName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ServiceType->ServiceName_isUsed = 1u;
                                grammar_id = 62;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceName>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=63

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ServiceType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 63;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 62:
            // Grammar: ID=62; read/write bits=1; START (ServiceCategory)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=63

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ServiceType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 63;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 63:
            // Grammar: ID=63; read/write bits=2; START (ServiceScope), START (FreeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceScope, serviceScopeType (string)); next=64

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ServiceType->ServiceScope.charactersLen);
                            if (error == 0)
                            {
                                if (ServiceType->ServiceScope.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ServiceType->ServiceScope.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ServiceType->ServiceScope.charactersLen, ServiceType->ServiceScope.characters, iso2_ServiceScope_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ServiceType->ServiceScope.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ServiceType->ServiceScope.characters[i]))
                                        {
                                            ServiceType->ServiceScope.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ServiceType->ServiceScope.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ServiceType->ServiceScope_isUsed = 1u;
                                grammar_id = 64;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (FreeService, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ServiceType->FreeService = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FreeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 64:
            // Grammar: ID=64; read/write bits=1; START (FreeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (FreeService, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ServiceType->FreeService = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FreeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureValue; type={http://www.w3.org/2000/09/xmldsig#}SignatureValueType; base type=base64Binary; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); CONTENT, SignatureValueType (1, 1);
static int decode_iso2_SignatureValueType(exi_bitstream_t* stream, struct iso2_SignatureValueType* SignatureValueType, char* xmlOut) {
    int grammar_id = 65;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SignatureValueType(SignatureValueType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 65:
            // Grammar: ID=65; read/write bits=2; START (Id), START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=66

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureValueType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureValueType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureValueType->Id.charactersLen, SignatureValueType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < SignatureValueType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureValueType->Id.characters[i]))
                                {
                                    SignatureValueType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureValueType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureValueType->Id_isUsed = 1u;
                    grammar_id = 66;

                    }
                    break;
                case 1:
                    {
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=3
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso2_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureValueType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureValueType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureValueType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 3;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 66:
            // Grammar: ID=66; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=3
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso2_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureValueType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureValueType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureValueType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 3;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SubCertificates; type={urn:iso:15118:2:2013:MsgDataTypes}SubCertificatesType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Certificate, certificateType (1, 4);
static int decode_iso2_SubCertificatesType(exi_bitstream_t* stream, struct iso2_SubCertificatesType* SubCertificatesType, char* xmlOut) {
    int grammar_id = 67;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SubCertificatesType(SubCertificatesType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 67:
            // Grammar: ID=67; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=68

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso2_certificateType_4_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso2_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 68;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 68:
            // Grammar: ID=68; read/write bits=2; START (Certificate), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=69

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso2_certificateType_4_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso2_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 69;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 69:
            // Grammar: ID=69; read/write bits=2; START (Certificate), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=70

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso2_certificateType_4_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso2_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 70;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 70:
            // Grammar: ID=70; read/write bits=2; START (Certificate), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso2_certificateType_4_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso2_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 3;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyInfo; type={http://www.w3.org/2000/09/xmldsig#}KeyInfoType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); KeyName, string (0, 1); KeyValue, KeyValueType (0, 1); RetrievalMethod, RetrievalMethodType (0, 1); X509Data, X509DataType (0, 1); PGPData, PGPDataType (0, 1); SPKIData, SPKIDataType (0, 1); MgmtData, string (0, 1); ANY, anyType (0, 1);
static int decode_iso2_KeyInfoType(exi_bitstream_t* stream, struct iso2_KeyInfoType* KeyInfoType, char* xmlOut) {
    int grammar_id = 71;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_KeyInfoType(KeyInfoType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 71:
            // Grammar: ID=71; read/write bits=4; START (Id), START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=72

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (KeyInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            KeyInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, KeyInfoType->Id.charactersLen, KeyInfoType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < KeyInfoType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(KeyInfoType->Id.characters[i]))
                                {
                                    KeyInfoType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, KeyInfoType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    KeyInfoType->Id_isUsed = 1u;
                    grammar_id = 72;

                    }
                    break;
                case 1:
                    {
                    // Event: START (KeyName, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso2_KeyName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < KeyInfoType->KeyName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->KeyName.characters[i]))
                                        {
                                            KeyInfoType->KeyName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->KeyName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    // decode: element
                    error = decode_iso2_KeyValueType(stream, &KeyInfoType->KeyValue, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    // decode: element
                    error = decode_iso2_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (X509Data, X509DataType (X509DataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    // decode: element
                    error = decode_iso2_X509DataType(stream, &KeyInfoType->X509Data, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    // decode: element
                    error = decode_iso2_PGPDataType(stream, &KeyInfoType->PGPData, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                    }
                    break;
                case 6:
                    {
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    // decode: element
                    error = decode_iso2_SPKIDataType(stream, &KeyInfoType->SPKIData, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                    }
                    break;
                case 7:
                    {
                    // Event: START (MgmtData, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso2_MgmtData_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < KeyInfoType->MgmtData.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->MgmtData.characters[i]))
                                        {
                                            KeyInfoType->MgmtData.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->MgmtData.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                    }
                    break;
                case 8:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyInfoType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyInfoType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyInfoType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 72:
            // Grammar: ID=72; read/write bits=4; START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (KeyName, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso2_KeyName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < KeyInfoType->KeyName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->KeyName.characters[i]))
                                        {
                                            KeyInfoType->KeyName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->KeyName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    // decode: element
                    error = decode_iso2_KeyValueType(stream, &KeyInfoType->KeyValue, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    // decode: element
                    error = decode_iso2_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (X509Data, X509DataType (X509DataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    // decode: element
                    error = decode_iso2_X509DataType(stream, &KeyInfoType->X509Data, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    // decode: element
                    error = decode_iso2_PGPDataType(stream, &KeyInfoType->PGPData, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    // decode: element
                    error = decode_iso2_SPKIDataType(stream, &KeyInfoType->SPKIData, xmlOut);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                    }
                    break;
                case 6:
                    {
                    // Event: START (MgmtData, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso2_MgmtData_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < KeyInfoType->MgmtData.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->MgmtData.characters[i]))
                                        {
                                            KeyInfoType->MgmtData.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->MgmtData.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                    }
                    break;
                case 7:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyInfoType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyInfoType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyInfoType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Object; type={http://www.w3.org/2000/09/xmldsig#}ObjectType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Encoding, anyURI (0, 1); Id, ID (0, 1); MimeType, string (0, 1); ANY, anyType (0, 1)(old 1, 1);
static int decode_iso2_ObjectType(exi_bitstream_t* stream, struct iso2_ObjectType* ObjectType, char* xmlOut) {
    int grammar_id = 73;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ObjectType(ObjectType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 73:
            // Grammar: ID=73; read/write bits=3; START (Encoding), START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Encoding, anyURI (anyURI)); next=74

                    strcat(xmlOut, " Encoding");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Encoding.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Encoding.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Encoding.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Encoding.charactersLen, ObjectType->Encoding.characters, iso2_Encoding_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->Encoding.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Encoding.characters[i]))
                                {
                                    ObjectType->Encoding.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Encoding.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Encoding_isUsed = 1u;
                    grammar_id = 74;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Id, ID (NCName)); next=75

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Id.characters[i]))
                                {
                                    ObjectType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 75;

                    }
                    break;
                case 2:
                    {
                    // Event: START (MimeType, string (string)); next=76

                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso2_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 76;

                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 5:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 74:
            // Grammar: ID=74; read/write bits=3; START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=75

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Id.characters[i]))
                                {
                                    ObjectType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 75;

                    }
                    break;
                case 1:
                    {
                    // Event: START (MimeType, string (string)); next=76

                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso2_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 76;

                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 4:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 75:
            // Grammar: ID=75; read/write bits=3; START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MimeType, string (string)); next=76

                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso2_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 76;

                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 76:
            // Grammar: ID=76; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=3
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso2_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 3;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SupportedEnergyTransferMode; type={urn:iso:15118:2:2013:MsgDataTypes}SupportedEnergyTransferModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EnergyTransferMode, EnergyTransferModeType (1, 6);
static int decode_iso2_SupportedEnergyTransferModeType(exi_bitstream_t* stream, struct iso2_SupportedEnergyTransferModeType* SupportedEnergyTransferModeType, char* xmlOut) {
    int grammar_id = 77;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SupportedEnergyTransferModeType(SupportedEnergyTransferModeType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 77:
            // Grammar: ID=77; read/write bits=1; START (EnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=78

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 78;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 78:
            // Grammar: ID=78; read/write bits=2; START (EnergyTransferMode), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=79

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 79;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 79:
            // Grammar: ID=79; read/write bits=2; START (EnergyTransferMode), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=80

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 80;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 80:
            // Grammar: ID=80; read/write bits=2; START (EnergyTransferMode), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=81

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 81;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 81:
            // Grammar: ID=81; read/write bits=2; START (EnergyTransferMode), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=82

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 82;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 82:
            // Grammar: ID=82; read/write bits=2; START (EnergyTransferMode), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferMode, EnergyTransferModeType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode");
                    // decode: enum array
                    if (SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen < iso2_EnergyTransferModeType_6_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                                if (error == 0)
                                {
                                    SupportedEnergyTransferModeType->EnergyTransferMode.array[SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen] = (iso2_EnergyTransferModeType)value;
                                    SupportedEnergyTransferModeType->EnergyTransferMode.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EnergyTransferMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain; type={urn:iso:15118:2:2013:MsgDataTypes}CertificateChainType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Certificate, certificateType (1, 1); SubCertificates, SubCertificatesType (0, 1);
static int decode_iso2_CertificateChainType(exi_bitstream_t* stream, struct iso2_CertificateChainType* CertificateChainType, char* xmlOut) {
    int grammar_id = 83;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CertificateChainType(CertificateChainType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 83:
            // Grammar: ID=83; read/write bits=2; START (Id), START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=84

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CertificateChainType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (CertificateChainType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CertificateChainType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CertificateChainType->Id.charactersLen, CertificateChainType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < CertificateChainType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(CertificateChainType->Id.characters[i]))
                                {
                                    CertificateChainType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, CertificateChainType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    CertificateChainType->Id_isUsed = 1u;
                    grammar_id = 84;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=85

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CertificateChainType->Certificate.bytesLen, &CertificateChainType->Certificate.bytes[0], iso2_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CertificateChainType->Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CertificateChainType->Certificate.bytesLen;) {
                            uint32_t octet_a = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CertificateChainType->Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 85;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 84:
            // Grammar: ID=84; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=85

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CertificateChainType->Certificate.bytesLen, &CertificateChainType->Certificate.bytes[0], iso2_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CertificateChainType->Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CertificateChainType->Certificate.bytesLen;) {
                            uint32_t octet_a = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CertificateChainType->Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 85;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 85:
            // Grammar: ID=85; read/write bits=2; START (SubCertificates), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SubCertificates, SubCertificatesType (SubCertificatesType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SubCertificates");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SubCertificates");
                    // decode: element
                    error = decode_iso2_SubCertificatesType(stream, &CertificateChainType->SubCertificates, xmlOut);
                    if (error == 0)
                    {
                        CertificateChainType->SubCertificates_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SubCertificates>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}BodyElement; type={urn:iso:15118:2:2013:MsgBody}BodyBaseType; base type=; content type=empty;
//          abstract=True; final=False;
static int decode_iso2_BodyBaseType(exi_bitstream_t* stream, struct iso2_BodyBaseType* BodyBaseType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)BodyBaseType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgHeader}Notification; type={urn:iso:15118:2:2013:MsgDataTypes}NotificationType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: FaultCode, faultCodeType (1, 1); FaultMsg, faultMsgType (0, 1);
static int decode_iso2_NotificationType(exi_bitstream_t* stream, struct iso2_NotificationType* NotificationType, char* xmlOut) {
    int grammar_id = 86;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_NotificationType(NotificationType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 86:
            // Grammar: ID=86; read/write bits=1; START (FaultCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (FaultCode, faultCodeType (string)); next=87

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FaultCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FaultCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                NotificationType->FaultCode = (iso2_faultCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_faultCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 87;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FaultCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 87:
            // Grammar: ID=87; read/write bits=2; START (FaultMsg), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (FaultMsg, faultMsgType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FaultMsg");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FaultMsg");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &NotificationType->FaultMsg.charactersLen);
                            if (error == 0)
                            {
                                if (NotificationType->FaultMsg.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    NotificationType->FaultMsg.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, NotificationType->FaultMsg.charactersLen, NotificationType->FaultMsg.characters, iso2_FaultMsg_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < NotificationType->FaultMsg.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(NotificationType->FaultMsg.characters[i]))
                                        {
                                            NotificationType->FaultMsg.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, NotificationType->FaultMsg.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                NotificationType->FaultMsg_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FaultMsg>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus; type={urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatusType; base type=EVSEStatusType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, EVSENotificationType (1, 1); EVSEIsolationStatus, isolationLevelType (0, 1); EVSEStatusCode, DC_EVSEStatusCodeType (1, 1);
static int decode_iso2_DC_EVSEStatusType(exi_bitstream_t* stream, struct iso2_DC_EVSEStatusType* DC_EVSEStatusType, char* xmlOut) {
    int grammar_id = 88;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DC_EVSEStatusType(DC_EVSEStatusType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 88:
            // Grammar: ID=88; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (NotificationMaxDelay, unsignedShort (unsignedInt)); next=89

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DC_EVSEStatusType->NotificationMaxDelay);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", DC_EVSEStatusType->NotificationMaxDelay);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 89;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 89:
            // Grammar: ID=89; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSENotification, EVSENotificationType (string)); next=90

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                DC_EVSEStatusType->EVSENotification = (iso2_EVSENotificationType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSENotificationType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 90;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 90:
            // Grammar: ID=90; read/write bits=2; START (EVSEIsolationStatus), START (EVSEStatusCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEIsolationStatus, isolationLevelType (string)); next=91

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEIsolationStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEIsolationStatus");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                DC_EVSEStatusType->EVSEIsolationStatus = (iso2_isolationLevelType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_isolationLevelType_reverse(value));
                                DC_EVSEStatusType->EVSEIsolationStatus_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 91;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEIsolationStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVSEStatusCode, DC_EVSEStatusCodeType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DC_EVSEStatusType->EVSEStatusCode = (iso2_DC_EVSEStatusCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_DC_EVSEStatusCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 91:
            // Grammar: ID=91; read/write bits=1; START (EVSEStatusCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEStatusCode, DC_EVSEStatusCodeType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DC_EVSEStatusType->EVSEStatusCode = (iso2_DC_EVSEStatusCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_DC_EVSEStatusCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus; type={urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatusType; base type=EVSEStatusType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, EVSENotificationType (1, 1); RCD, boolean (1, 1);
static int decode_iso2_AC_EVSEStatusType(exi_bitstream_t* stream, struct iso2_AC_EVSEStatusType* AC_EVSEStatusType, char* xmlOut) {
    int grammar_id = 92;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_AC_EVSEStatusType(AC_EVSEStatusType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 92:
            // Grammar: ID=92; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (NotificationMaxDelay, unsignedShort (unsignedInt)); next=93

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &AC_EVSEStatusType->NotificationMaxDelay);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", AC_EVSEStatusType->NotificationMaxDelay);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 93;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 93:
            // Grammar: ID=93; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSENotification, EVSENotificationType (string)); next=94

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                AC_EVSEStatusType->EVSENotification = (iso2_EVSENotificationType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSENotificationType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 94;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 94:
            // Grammar: ID=94; read/write bits=1; START (RCD)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RCD, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RCD");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RCD");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AC_EVSEStatusType->RCD = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RCD>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}EVSEStatus; type={urn:iso:15118:2:2013:MsgDataTypes}EVSEStatusType; base type=; content type=ELEMENT-ONLY;
//          abstract=True; final=False;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, EVSENotificationType (1, 1); AC_EVSEStatus, AC_EVSEStatusType (1, 1); DC_EVSEStatus, DC_EVSEStatusType (1, 1);
static int decode_iso2_EVSEStatusType(exi_bitstream_t* stream, struct iso2_EVSEStatusType* EVSEStatusType, char* xmlOut) {
    int grammar_id = 95;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_EVSEStatusType(EVSEStatusType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 95:
            // Grammar: ID=95; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (NotificationMaxDelay, unsignedShort (unsignedInt)); next=96

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &EVSEStatusType->NotificationMaxDelay);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", EVSEStatusType->NotificationMaxDelay);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 96;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}NotificationMaxDelay>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 96:
            // Grammar: ID=96; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSENotification, EVSENotificationType (string)); next=97

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                EVSEStatusType->EVSENotification = (iso2_EVSENotificationType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSENotificationType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 97;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSENotification>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 97:
            // Grammar: ID=97; read/write bits=1; START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=98

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &EVSEStatusType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 98;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 98:
            // Grammar: ID=98; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &EVSEStatusType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}SelectedServiceList; type={urn:iso:15118:2:2013:MsgDataTypes}SelectedServiceListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SelectedService, SelectedServiceType (1, 16);
static int decode_iso2_SelectedServiceListType(exi_bitstream_t* stream, struct iso2_SelectedServiceListType* SelectedServiceListType, char* xmlOut) {
    int grammar_id = 99;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SelectedServiceListType(SelectedServiceListType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 99:
            // Grammar: ID=99; read/write bits=1; START (SelectedService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=100

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 100;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 100:
            // Grammar: ID=100; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=101

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 101;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 101:
            // Grammar: ID=101; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=102

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 102;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 102:
            // Grammar: ID=102; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=103

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 103;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 103:
            // Grammar: ID=103; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=104

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 104;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 104:
            // Grammar: ID=104; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=105

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 105;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 105:
            // Grammar: ID=105; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=106

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 106;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 106:
            // Grammar: ID=106; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=107

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 107;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 107:
            // Grammar: ID=107; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=108

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 108;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 108:
            // Grammar: ID=108; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=109

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 109;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 109:
            // Grammar: ID=109; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=110

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 110;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 110:
            // Grammar: ID=110; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=111

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 111;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 111:
            // Grammar: ID=111; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=112

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 112;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 112:
            // Grammar: ID=112; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=113

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 113;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 113:
            // Grammar: ID=113; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=114

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 114;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 114:
            // Grammar: ID=114; read/write bits=2; START (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso2_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PaymentOptionList; type={urn:iso:15118:2:2013:MsgDataTypes}PaymentOptionListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PaymentOption, paymentOptionType (1, 2);
static int decode_iso2_PaymentOptionListType(exi_bitstream_t* stream, struct iso2_PaymentOptionListType* PaymentOptionListType, char* xmlOut) {
    int grammar_id = 115;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PaymentOptionListType(PaymentOptionListType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 115:
            // Grammar: ID=115; read/write bits=1; START (PaymentOption)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PaymentOption, paymentOptionType (string)); next=116

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption");
                    // decode: enum array
                    if (PaymentOptionListType->PaymentOption.arrayLen < iso2_paymentOptionType_2_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                                if (error == 0)
                                {
                                    PaymentOptionListType->PaymentOption.array[PaymentOptionListType->PaymentOption.arrayLen] = (iso2_paymentOptionType)value;
                                    PaymentOptionListType->PaymentOption.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_paymentOptionType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 116;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 116:
            // Grammar: ID=116; read/write bits=2; START (PaymentOption), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PaymentOption, paymentOptionType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption");
                    // decode: enum array
                    if (PaymentOptionListType->PaymentOption.arrayLen < iso2_paymentOptionType_2_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                                if (error == 0)
                                {
                                    PaymentOptionListType->PaymentOption.array[PaymentOptionListType->PaymentOption.arrayLen] = (iso2_paymentOptionType)value;
                                    PaymentOptionListType->PaymentOption.arrayLen++;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_paymentOptionType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PaymentOption>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Signature; type={http://www.w3.org/2000/09/xmldsig#}SignatureType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignedInfo, SignedInfoType (1, 1); SignatureValue, SignatureValueType (1, 1); KeyInfo, KeyInfoType (0, 1); Object, ObjectType (0, 1);
static int decode_iso2_SignatureType(exi_bitstream_t* stream, struct iso2_SignatureType* SignatureType, char* xmlOut) {
    int grammar_id = 117;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SignatureType(SignatureType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 117:
            // Grammar: ID=117; read/write bits=2; START (Id), START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=118

                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureType->Id.charactersLen, SignatureType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < SignatureType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureType->Id.characters[i]))
                                {
                                    SignatureType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureType->Id_isUsed = 1u;
                    grammar_id = 118;

                    }
                    break;
                case 1:
                    {
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=119

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    // decode: element
                    error = decode_iso2_SignedInfoType(stream, &SignatureType->SignedInfo, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 119;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 118:
            // Grammar: ID=118; read/write bits=1; START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=119

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    // decode: element
                    error = decode_iso2_SignedInfoType(stream, &SignatureType->SignedInfo, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 119;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 119:
            // Grammar: ID=119; read/write bits=1; START (SignatureValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureValue, SignatureValueType (base64Binary)); next=120

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureValue");
                    // decode: element
                    error = decode_iso2_SignatureValueType(stream, &SignatureType->SignatureValue, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 120;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 120:
            // Grammar: ID=120; read/write bits=2; START (KeyInfo), START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (KeyInfo, KeyInfoType (KeyInfoType)); next=122

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyInfo");
                    // decode: element
                    error = decode_iso2_KeyInfoType(stream, &SignatureType->KeyInfo, xmlOut);
                    if (error == 0)
                    {
                        SignatureType->KeyInfo_isUsed = 1u;
                        grammar_id = 122;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyInfo>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=121

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso2_ObjectType(stream, &SignatureType->Object, xmlOut);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 121;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 121:
            // Grammar: ID=121; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso2_ObjectType(stream, &SignatureType->Object, xmlOut);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 122:
            // Grammar: ID=122; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=123

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso2_ObjectType(stream, &SignatureType->Object, xmlOut);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 123;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 123:
            // Grammar: ID=123; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso2_ObjectType(stream, &SignatureType->Object, xmlOut);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs; type={urn:iso:15118:2:2013:MsgDataTypes}ListOfRootCertificateIDsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: RootCertificateID, X509IssuerSerialType (1, 5);
static int decode_iso2_ListOfRootCertificateIDsType(exi_bitstream_t* stream, struct iso2_ListOfRootCertificateIDsType* ListOfRootCertificateIDsType, char* xmlOut) {
    int grammar_id = 124;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ListOfRootCertificateIDsType(ListOfRootCertificateIDsType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 124:
            // Grammar: ID=124; read/write bits=1; START (RootCertificateID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=125

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 125;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 125:
            // Grammar: ID=125; read/write bits=2; START (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=126

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 126;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 126:
            // Grammar: ID=126; read/write bits=2; START (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=127

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 127;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 127:
            // Grammar: ID=127; read/write bits=2; START (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=128

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 128;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 128:
            // Grammar: ID=128; read/write bits=2; START (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=129

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 129;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 129:
            // Grammar: ID=129; read/write bits=2; START (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso2_X509IssuerSerialType_5_ARRAY_SIZE)
                    {

                        error = decode_iso2_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage; type={urn:iso:15118:2:2013:MsgDataTypes}PhysicalValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Multiplier, unitMultiplierType (1, 1); Unit, unitSymbolType (1, 1); Value, short (1, 1);
static int decode_iso2_PhysicalValueType(exi_bitstream_t* stream, struct iso2_PhysicalValueType* PhysicalValueType, char* xmlOut) {
    int grammar_id = 130;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PhysicalValueType(PhysicalValueType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 130:
            // Grammar: ID=130; read/write bits=1; START (Multiplier)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Multiplier, unitMultiplierType (byte)); next=131

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Multiplier");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Multiplier");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                // type has min_value = -3
                                PhysicalValueType->Multiplier = (int8_t)(value + -3);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PhysicalValueType->Multiplier);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 131;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Multiplier>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 131:
            // Grammar: ID=131; read/write bits=1; START (Unit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Unit, unitSymbolType (string)); next=132

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Unit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Unit");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                PhysicalValueType->Unit = (iso2_unitSymbolType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_unitSymbolType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 132;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Unit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 132:
            // Grammar: ID=132; read/write bits=1; START (Value)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Value, short (int)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Value");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Value");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &PhysicalValueType->Value);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", PhysicalValueType->Value);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Value>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost; type={urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCostType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: startValue, PhysicalValueType (1, 1); Cost, CostType (1, 3);
static int decode_iso2_ConsumptionCostType(exi_bitstream_t* stream, struct iso2_ConsumptionCostType* ConsumptionCostType, char* xmlOut) {
    int grammar_id = 133;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ConsumptionCostType(ConsumptionCostType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 133:
            // Grammar: ID=133; read/write bits=1; START (startValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (startValue, PhysicalValueType (PhysicalValueType)); next=134

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}startValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}startValue");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &ConsumptionCostType->startValue, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 134;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}startValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 134:
            // Grammar: ID=134; read/write bits=1; START (Cost)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Cost, CostType (CostType)); next=135

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    // decode: element array
                    if (ConsumptionCostType->Cost.arrayLen < iso2_CostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_CostType(stream, &ConsumptionCostType->Cost.array[ConsumptionCostType->Cost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 135;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Cost>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 135:
            // Grammar: ID=135; read/write bits=2; START (Cost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Cost, CostType (CostType)); next=136

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    // decode: element array
                    if (ConsumptionCostType->Cost.arrayLen < iso2_CostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_CostType(stream, &ConsumptionCostType->Cost.array[ConsumptionCostType->Cost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 136;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Cost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 136:
            // Grammar: ID=136; read/write bits=2; START (Cost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Cost, CostType (CostType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Cost");
                    // decode: element array
                    if (ConsumptionCostType->Cost.arrayLen < iso2_CostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_CostType(stream, &ConsumptionCostType->Cost.array[ConsumptionCostType->Cost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Cost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry; type={urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntryType; base type=EntryType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: RelativeTimeInterval, RelativeTimeIntervalType (0, 1); TimeInterval, IntervalType (0, 1); PMax, PhysicalValueType (1, 1);
static int decode_iso2_PMaxScheduleEntryType(exi_bitstream_t* stream, struct iso2_PMaxScheduleEntryType* PMaxScheduleEntryType, char* xmlOut) {
    int grammar_id = 137;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PMaxScheduleEntryType(PMaxScheduleEntryType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 137:
            // Grammar: ID=137; read/write bits=2; START (RelativeTimeInterval), START (TimeInterval)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RelativeTimeInterval, RelativeTimeIntervalType (IntervalType)); next=138

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval");
                    // decode: element
                    error = decode_iso2_RelativeTimeIntervalType(stream, &PMaxScheduleEntryType->RelativeTimeInterval, xmlOut);
                    if (error == 0)
                    {
                        PMaxScheduleEntryType->RelativeTimeInterval_isUsed = 1u;
                        grammar_id = 138;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval>");
                    }
                    break;
                case 1:
                    {
                    // Abstract element or type: TimeInterval, IntervalType (IntervalType)
                    // decode: element
                    error = decode_iso2_IntervalType(stream, &PMaxScheduleEntryType->TimeInterval, xmlOut);
                    if (error == 0)
                    {
                        PMaxScheduleEntryType->TimeInterval_isUsed = 1u;
                        grammar_id = 138;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 138:
            // Grammar: ID=138; read/write bits=1; START (PMax)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMax, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMax");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMax");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &PMaxScheduleEntryType->PMax, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMax>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry; type={urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntryType; base type=EntryType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: RelativeTimeInterval, RelativeTimeIntervalType (0, 1); TimeInterval, IntervalType (0, 1); EPriceLevel, unsignedByte (0, 1); ConsumptionCost, ConsumptionCostType (0, 3);
static int decode_iso2_SalesTariffEntryType(exi_bitstream_t* stream, struct iso2_SalesTariffEntryType* SalesTariffEntryType, char* xmlOut) {
    int grammar_id = 139;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SalesTariffEntryType(SalesTariffEntryType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 139:
            // Grammar: ID=139; read/write bits=2; START (RelativeTimeInterval), START (TimeInterval)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RelativeTimeInterval, RelativeTimeIntervalType (IntervalType)); next=140

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval");
                    // decode: element
                    error = decode_iso2_RelativeTimeIntervalType(stream, &SalesTariffEntryType->RelativeTimeInterval, xmlOut);
                    if (error == 0)
                    {
                        SalesTariffEntryType->RelativeTimeInterval_isUsed = 1u;
                        grammar_id = 140;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}RelativeTimeInterval>");
                    }
                    break;
                case 1:
                    {
                    // Abstract element or type: TimeInterval, IntervalType (IntervalType)
                    // decode: element
                    error = decode_iso2_IntervalType(stream, &SalesTariffEntryType->TimeInterval, xmlOut);
                    if (error == 0)
                    {
                        SalesTariffEntryType->TimeInterval_isUsed = 1u;
                        grammar_id = 140;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 140:
            // Grammar: ID=140; read/write bits=2; START (EPriceLevel), START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EPriceLevel, unsignedByte (unsignedShort)); next=143

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EPriceLevel");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EPriceLevel");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                SalesTariffEntryType->EPriceLevel = (uint8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SalesTariffEntryType->EPriceLevel);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                SalesTariffEntryType->EPriceLevel_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 143;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EPriceLevel>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=141

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 141;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 141:
            // Grammar: ID=141; read/write bits=2; START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=142

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 142;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 142:
            // Grammar: ID=142; read/write bits=2; START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 143:
            // Grammar: ID=143; read/write bits=2; START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=144

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 144;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 144:
            // Grammar: ID=144; read/write bits=2; START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=145

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 145;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 145:
            // Grammar: ID=145; read/write bits=2; START (ConsumptionCost), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ConsumptionCost, ConsumptionCostType (ConsumptionCostType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost");
                    // decode: element array
                    if (SalesTariffEntryType->ConsumptionCost.arrayLen < iso2_ConsumptionCostType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_ConsumptionCostType(stream, &SalesTariffEntryType->ConsumptionCost.array[SalesTariffEntryType->ConsumptionCost.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ConsumptionCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}PMaxSchedule; type={urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PMaxScheduleEntry, PMaxScheduleEntryType (1, 16);
static int decode_iso2_PMaxScheduleType(exi_bitstream_t* stream, struct iso2_PMaxScheduleType* PMaxScheduleType, char* xmlOut) {
    int grammar_id = 146;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PMaxScheduleType(PMaxScheduleType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 146:
            // Grammar: ID=146; read/write bits=1; START (PMaxScheduleEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=147

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 147;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 147:
            // Grammar: ID=147; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=148

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 148;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 148:
            // Grammar: ID=148; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=149

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 149;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 149:
            // Grammar: ID=149; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=150

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 150;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 150:
            // Grammar: ID=150; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=151

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 151;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 151:
            // Grammar: ID=151; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=152

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 152;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 152:
            // Grammar: ID=152; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=153

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 153;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 153:
            // Grammar: ID=153; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=154

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 154;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 154:
            // Grammar: ID=154; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=155

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 155;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 155:
            // Grammar: ID=155; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=156

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 156;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 156:
            // Grammar: ID=156; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=157

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 157;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 157:
            // Grammar: ID=157; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=158

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 158;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 158:
            // Grammar: ID=158; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=159

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 159;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 159:
            // Grammar: ID=159; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=160

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 160;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 160:
            // Grammar: ID=160; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=161

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 161;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 161:
            // Grammar: ID=161; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=162

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 162;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 162:
            // Grammar: ID=162; read/write bits=2; START (PMaxScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxScheduleEntry, PMaxScheduleEntryType (EntryType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry");
                    // decode: element array
                    if (PMaxScheduleType->PMaxScheduleEntry.arrayLen < iso2_PMaxScheduleEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_PMaxScheduleEntryType(stream, &PMaxScheduleType->PMaxScheduleEntry.array[PMaxScheduleType->PMaxScheduleEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}Parameter; type={urn:iso:15118:2:2013:MsgDataTypes}ParameterType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True;
// Particle: Name, string (1, 1); boolValue, boolean (0, 1); byteValue, byte (0, 1); shortValue, short (0, 1); intValue, int (0, 1); physicalValue, PhysicalValueType (0, 1); stringValue, string (0, 1);
static int decode_iso2_ParameterType(exi_bitstream_t* stream, struct iso2_ParameterType* ParameterType, char* xmlOut) {
    int grammar_id = 163;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ParameterType(ParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 163:
            // Grammar: ID=163; read/write bits=1; START (Name)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Name, string (string)); next=164

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Name");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ParameterType->Name.charactersLen);
                    if (error == 0)
                    {
                        if (ParameterType->Name.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ParameterType->Name.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ParameterType->Name.charactersLen, ParameterType->Name.characters, iso2_Name_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ParameterType->Name.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ParameterType->Name.characters[i]))
                                {
                                    ParameterType->Name.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ParameterType->Name.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 164;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 164:
            // Grammar: ID=164; read/write bits=3; START (boolValue), START (byteValue), START (shortValue), START (intValue), START (physicalValue), START (stringValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (boolValue, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}boolValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}boolValue");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ParameterType->boolValue = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ParameterType->boolValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}boolValue>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (byteValue, byte (short)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}byteValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}byteValue");
                    // decode: byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = -128
                                ParameterType->byteValue = (int8_t)(value + -128);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", ParameterType->byteValue);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                ParameterType->byteValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}byteValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (shortValue, short (int)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}shortValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}shortValue");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &ParameterType->shortValue);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", ParameterType->shortValue);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        ParameterType->shortValue_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}shortValue>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (intValue, int (long)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}intValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}intValue");
                    // decode: int
                    error = decode_exi_type_integer32(stream, &ParameterType->intValue);
                    if (error == 0)
                    {
                        char append[12]; // max length: 10 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", ParameterType->intValue);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        ParameterType->intValue_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}intValue>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (physicalValue, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}physicalValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}physicalValue");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &ParameterType->physicalValue, xmlOut);
                    if (error == 0)
                    {
                        ParameterType->physicalValue_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}physicalValue>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (stringValue, string (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}stringValue");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}stringValue");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ParameterType->stringValue.charactersLen);
                            if (error == 0)
                            {
                                if (ParameterType->stringValue.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ParameterType->stringValue.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ParameterType->stringValue.charactersLen, ParameterType->stringValue.characters, iso2_stringValue_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ParameterType->stringValue.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ParameterType->stringValue.characters[i]))
                                        {
                                            ParameterType->stringValue.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ParameterType->stringValue.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ParameterType->stringValue_isUsed = 1u;
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}stringValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SalesTariff; type={urn:iso:15118:2:2013:MsgDataTypes}SalesTariffType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SalesTariffID, SAIDType (1, 1); SalesTariffDescription, tariffDescriptionType (0, 1); NumEPriceLevels, unsignedByte (0, 1); SalesTariffEntry, SalesTariffEntryType (1, 16);
static int decode_iso2_SalesTariffType(exi_bitstream_t* stream, struct iso2_SalesTariffType* SalesTariffType, char* xmlOut) {
    int grammar_id = 165;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SalesTariffType(SalesTariffType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 165:
            // Grammar: ID=165; read/write bits=2; START (Id), START (SalesTariffID)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=166

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SalesTariffType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SalesTariffType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SalesTariffType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SalesTariffType->Id.charactersLen, SalesTariffType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < SalesTariffType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SalesTariffType->Id.characters[i]))
                                {
                                    SalesTariffType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SalesTariffType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SalesTariffType->Id_isUsed = 1u;
                    grammar_id = 166;

                    }
                    break;
                case 1:
                    {
                    // Event: START (SalesTariffID, SAIDType (unsignedByte)); next=167

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                SalesTariffType->SalesTariffID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SalesTariffType->SalesTariffID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 167;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 166:
            // Grammar: ID=166; read/write bits=1; START (SalesTariffID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffID, SAIDType (unsignedByte)); next=167

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                SalesTariffType->SalesTariffID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SalesTariffType->SalesTariffID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 167;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 167:
            // Grammar: ID=167; read/write bits=2; START (SalesTariffDescription), START (NumEPriceLevels), START (SalesTariffEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffDescription, tariffDescriptionType (string)); next=184

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffDescription");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffDescription");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SalesTariffType->SalesTariffDescription.charactersLen);
                            if (error == 0)
                            {
                                if (SalesTariffType->SalesTariffDescription.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SalesTariffType->SalesTariffDescription.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SalesTariffType->SalesTariffDescription.charactersLen, SalesTariffType->SalesTariffDescription.characters, iso2_SalesTariffDescription_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < SalesTariffType->SalesTariffDescription.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SalesTariffType->SalesTariffDescription.characters[i]))
                                        {
                                            SalesTariffType->SalesTariffDescription.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SalesTariffType->SalesTariffDescription.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                SalesTariffType->SalesTariffDescription_isUsed = 1u;
                                grammar_id = 184;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffDescription>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (NumEPriceLevels, unsignedByte (unsignedShort)); next=201

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                SalesTariffType->NumEPriceLevels = (uint8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SalesTariffType->NumEPriceLevels);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                SalesTariffType->NumEPriceLevels_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 201;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=168

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 168;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 168:
            // Grammar: ID=168; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=169

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 169;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 169:
            // Grammar: ID=169; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=170

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 170;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 170:
            // Grammar: ID=170; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=171

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 171;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 171:
            // Grammar: ID=171; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=172

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 172;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 172:
            // Grammar: ID=172; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=173

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 173;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 173:
            // Grammar: ID=173; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=174

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 174;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 174:
            // Grammar: ID=174; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=175

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 175;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 175:
            // Grammar: ID=175; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=176

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 176;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 176:
            // Grammar: ID=176; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=177

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 177;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 177:
            // Grammar: ID=177; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=178

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 178;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 178:
            // Grammar: ID=178; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=179

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 179;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 179:
            // Grammar: ID=179; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=180

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 180;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 180:
            // Grammar: ID=180; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=181

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 181;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 181:
            // Grammar: ID=181; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=182

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 182;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 182:
            // Grammar: ID=182; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=183

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 183;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 183:
            // Grammar: ID=183; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 184:
            // Grammar: ID=184; read/write bits=2; START (NumEPriceLevels), START (SalesTariffEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (NumEPriceLevels, unsignedByte (unsignedShort)); next=201

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                SalesTariffType->NumEPriceLevels = (uint8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SalesTariffType->NumEPriceLevels);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                SalesTariffType->NumEPriceLevels_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 201;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}NumEPriceLevels>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=185

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 185;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 185:
            // Grammar: ID=185; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=186

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 186;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 186:
            // Grammar: ID=186; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=187

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 187;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 187:
            // Grammar: ID=187; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=188

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 188;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 188:
            // Grammar: ID=188; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=189

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 189;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 189:
            // Grammar: ID=189; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=190

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 190;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 190:
            // Grammar: ID=190; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=191

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 191;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 191:
            // Grammar: ID=191; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=192

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 192;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 192:
            // Grammar: ID=192; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=193

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 193;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 193:
            // Grammar: ID=193; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=194

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 194;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 194:
            // Grammar: ID=194; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=195

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 195;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 195:
            // Grammar: ID=195; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=196

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 196;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 196:
            // Grammar: ID=196; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=197

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 197;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 197:
            // Grammar: ID=197; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=198

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 198;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 198:
            // Grammar: ID=198; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=199

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 199;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 199:
            // Grammar: ID=199; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=200

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 200;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 200:
            // Grammar: ID=200; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 201:
            // Grammar: ID=201; read/write bits=1; START (SalesTariffEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=202

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 202;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 202:
            // Grammar: ID=202; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=203

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 203;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 203:
            // Grammar: ID=203; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=204

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 204;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 204:
            // Grammar: ID=204; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=205

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 205;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 205:
            // Grammar: ID=205; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=206

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 206;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 206:
            // Grammar: ID=206; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=207

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 207;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 207:
            // Grammar: ID=207; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=208

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 208;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 208:
            // Grammar: ID=208; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=209

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 209;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 209:
            // Grammar: ID=209; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=210

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 210;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 210:
            // Grammar: ID=210; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=211

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 211;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 211:
            // Grammar: ID=211; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=212

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 212;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 212:
            // Grammar: ID=212; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=213

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 213;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 213:
            // Grammar: ID=213; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=214

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 214;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 214:
            // Grammar: ID=214; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=215

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 215;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 215:
            // Grammar: ID=215; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=216

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 216;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 216:
            // Grammar: ID=216; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=217

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 217;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 217:
            // Grammar: ID=217; read/write bits=2; START (SalesTariffEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariffEntry, SalesTariffEntryType (EntryType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry");
                    // decode: element array
                    if (SalesTariffType->SalesTariffEntry.arrayLen < iso2_SalesTariffEntryType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_SalesTariffEntryType(stream, &SalesTariffType->SalesTariffEntry.array[SalesTariffType->SalesTariffEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariffEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry; type={urn:iso:15118:2:2013:MsgDataTypes}ProfileEntryType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ChargingProfileEntryStart, unsignedInt (1, 1); ChargingProfileEntryMaxPower, PhysicalValueType (1, 1); ChargingProfileEntryMaxNumberOfPhasesInUse, maxNumPhasesType (0, 1);
static int decode_iso2_ProfileEntryType(exi_bitstream_t* stream, struct iso2_ProfileEntryType* ProfileEntryType, char* xmlOut) {
    int grammar_id = 218;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ProfileEntryType(ProfileEntryType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 218:
            // Grammar: ID=218; read/write bits=1; START (ChargingProfileEntryStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingProfileEntryStart, unsignedInt (unsignedLong)); next=219

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryStart");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryStart");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &ProfileEntryType->ChargingProfileEntryStart);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ProfileEntryType->ChargingProfileEntryStart);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 219;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 219:
            // Grammar: ID=219; read/write bits=1; START (ChargingProfileEntryMaxPower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingProfileEntryMaxPower, PhysicalValueType (PhysicalValueType)); next=220

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxPower");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxPower");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &ProfileEntryType->ChargingProfileEntryMaxPower, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 220;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxPower>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 220:
            // Grammar: ID=220; read/write bits=2; START (ChargingProfileEntryMaxNumberOfPhasesInUse), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingProfileEntryMaxNumberOfPhasesInUse, maxNumPhasesType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxNumberOfPhasesInUse");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxNumberOfPhasesInUse");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                ProfileEntryType->ChargingProfileEntryMaxNumberOfPhasesInUse = (int8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", ProfileEntryType->ChargingProfileEntryMaxNumberOfPhasesInUse);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                ProfileEntryType->ChargingProfileEntryMaxNumberOfPhasesInUse_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileEntryMaxNumberOfPhasesInUse>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple; type={urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTupleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SAScheduleTupleID, SAIDType (1, 1); PMaxSchedule, PMaxScheduleType (1, 1); SalesTariff, SalesTariffType (0, 1);
static int decode_iso2_SAScheduleTupleType(exi_bitstream_t* stream, struct iso2_SAScheduleTupleType* SAScheduleTupleType, char* xmlOut) {
    int grammar_id = 221;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SAScheduleTupleType(SAScheduleTupleType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 221:
            // Grammar: ID=221; read/write bits=1; START (SAScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTupleID, SAIDType (unsignedByte)); next=222

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTupleID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                SAScheduleTupleType->SAScheduleTupleID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", SAScheduleTupleType->SAScheduleTupleID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 222;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 222:
            // Grammar: ID=222; read/write bits=1; START (PMaxSchedule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PMaxSchedule, PMaxScheduleType (PMaxScheduleType)); next=223

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}PMaxSchedule");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}PMaxSchedule");
                    // decode: element
                    error = decode_iso2_PMaxScheduleType(stream, &SAScheduleTupleType->PMaxSchedule, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 223;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}PMaxSchedule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 223:
            // Grammar: ID=223; read/write bits=2; START (SalesTariff), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SalesTariff, SalesTariffType (SalesTariffType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariff");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SalesTariff");
                    // decode: element
                    error = decode_iso2_SalesTariffType(stream, &SAScheduleTupleType->SalesTariff, xmlOut);
                    if (error == 0)
                    {
                        SAScheduleTupleType->SalesTariff_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SalesTariff>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}ParameterSet; type={urn:iso:15118:2:2013:MsgDataTypes}ParameterSetType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ParameterSetID, short (1, 1); Parameter, ParameterType (1, 16);
static int decode_iso2_ParameterSetType(exi_bitstream_t* stream, struct iso2_ParameterSetType* ParameterSetType, char* xmlOut) {
    int grammar_id = 224;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ParameterSetType(ParameterSetType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 224:
            // Grammar: ID=224; read/write bits=1; START (ParameterSetID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSetID, short (int)); next=225

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &ParameterSetType->ParameterSetID);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", ParameterSetType->ParameterSetID);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        grammar_id = 225;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSetID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 225:
            // Grammar: ID=225; read/write bits=1; START (Parameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=226

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 226;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 226:
            // Grammar: ID=226; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=227

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 227;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 227:
            // Grammar: ID=227; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=228

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 228;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 228:
            // Grammar: ID=228; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=229

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 229;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 229:
            // Grammar: ID=229; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=230

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 230;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 230:
            // Grammar: ID=230; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=231

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 231;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 231:
            // Grammar: ID=231; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=232

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 232;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 232:
            // Grammar: ID=232; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=233

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 233;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 233:
            // Grammar: ID=233; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=234

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 234;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 234:
            // Grammar: ID=234; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=235

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 235;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 235:
            // Grammar: ID=235; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=236

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 236;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 236:
            // Grammar: ID=236; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=237

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 237;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 237:
            // Grammar: ID=237; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=238

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 238;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 238:
            // Grammar: ID=238; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=239

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 239;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 239:
            // Grammar: ID=239; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=240

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 240;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 240:
            // Grammar: ID=240; read/write bits=2; START (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso2_ParameterType_16_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargingProfile; type={urn:iso:15118:2:2013:MsgDataTypes}ChargingProfileType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ProfileEntry, ProfileEntryType (1, 24);
static int decode_iso2_ChargingProfileType(exi_bitstream_t* stream, struct iso2_ChargingProfileType* ChargingProfileType, char* xmlOut) {
    int grammar_id = 241;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ChargingProfileType(ChargingProfileType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 241:
            // Grammar: ID=241; read/write bits=1; START (ProfileEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=242

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 242;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 242:
            // Grammar: ID=242; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=243

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 243;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 243:
            // Grammar: ID=243; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=244

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 244;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 244:
            // Grammar: ID=244; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=245

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 245;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 245:
            // Grammar: ID=245; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=246

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 246;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 246:
            // Grammar: ID=246; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=247

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 247;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 247:
            // Grammar: ID=247; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=248

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 248;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 248:
            // Grammar: ID=248; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=249

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 249;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 249:
            // Grammar: ID=249; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=250

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 250;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 250:
            // Grammar: ID=250; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=251

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 251;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 251:
            // Grammar: ID=251; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=252

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 252;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 252:
            // Grammar: ID=252; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=253

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 253;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 253:
            // Grammar: ID=253; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=254

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 254;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 254:
            // Grammar: ID=254; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=255

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 255;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 255:
            // Grammar: ID=255; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=256

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 256;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 256:
            // Grammar: ID=256; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=257

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 257;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 257:
            // Grammar: ID=257; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=258

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 258;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 258:
            // Grammar: ID=258; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=259

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 259;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 259:
            // Grammar: ID=259; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=260

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 260;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 260:
            // Grammar: ID=260; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=261

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 261;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 261:
            // Grammar: ID=261; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=262

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 262;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 262:
            // Grammar: ID=262; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=263

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 263;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 263:
            // Grammar: ID=263; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=264

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 264;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 264:
            // Grammar: ID=264; read/write bits=2; START (ProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ProfileEntry, ProfileEntryType (ProfileEntryType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry");
                    // decode: element array
                    if (ChargingProfileType->ProfileEntry.arrayLen < iso2_ProfileEntryType_24_ARRAY_SIZE)
                    {

                        error = decode_iso2_ProfileEntryType(stream, &ChargingProfileType->ProfileEntry.array[ChargingProfileType->ProfileEntry.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}MeterInfo; type={urn:iso:15118:2:2013:MsgDataTypes}MeterInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: MeterID, meterIDType (1, 1); MeterReading, unsignedLong (0, 1); SigMeterReading, sigMeterReadingType (0, 1); MeterStatus, meterStatusType (0, 1); TMeter, long (0, 1);
static int decode_iso2_MeterInfoType(exi_bitstream_t* stream, struct iso2_MeterInfoType* MeterInfoType, char* xmlOut) {
    int grammar_id = 265;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_MeterInfoType(MeterInfoType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 265:
            // Grammar: ID=265; read/write bits=1; START (MeterID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterID, meterIDType (string)); next=266

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}MeterID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}MeterID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &MeterInfoType->MeterID.charactersLen);
                            if (error == 0)
                            {
                                if (MeterInfoType->MeterID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    MeterInfoType->MeterID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, MeterInfoType->MeterID.charactersLen, MeterInfoType->MeterID.characters, iso2_MeterID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < MeterInfoType->MeterID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(MeterInfoType->MeterID.characters[i]))
                                        {
                                            MeterInfoType->MeterID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, MeterInfoType->MeterID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 266;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}MeterID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 266:
            // Grammar: ID=266; read/write bits=3; START (MeterReading), START (SigMeterReading), START (MeterStatus), START (TMeter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterReading, unsignedLong (nonNegativeInteger)); next=267

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}MeterReading");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}MeterReading");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterReading);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%" PRIu64, MeterInfoType->MeterReading);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterReading_isUsed = 1u;
                        grammar_id = 267;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}MeterReading>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (SigMeterReading, sigMeterReadingType (base64Binary)); next=268

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->SigMeterReading.bytesLen, &MeterInfoType->SigMeterReading.bytes[0], iso2_sigMeterReadingType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->SigMeterReading.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->SigMeterReading.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->SigMeterReading.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->SigMeterReading_isUsed = 1u;
                        grammar_id = 268;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (MeterStatus, meterStatusType (short)); next=269

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 269;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (TMeter, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &MeterInfoType->TMeter);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, MeterInfoType->TMeter);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->TMeter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}TMeter>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 267:
            // Grammar: ID=267; read/write bits=3; START (SigMeterReading), START (MeterStatus), START (TMeter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SigMeterReading, sigMeterReadingType (base64Binary)); next=268

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->SigMeterReading.bytesLen, &MeterInfoType->SigMeterReading.bytes[0], iso2_sigMeterReadingType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->SigMeterReading.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->SigMeterReading.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->SigMeterReading.bytesLen ? (unsigned char) MeterInfoType->SigMeterReading.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->SigMeterReading.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->SigMeterReading_isUsed = 1u;
                        grammar_id = 268;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SigMeterReading>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterStatus, meterStatusType (short)); next=269

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 269;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TMeter, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &MeterInfoType->TMeter);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, MeterInfoType->TMeter);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->TMeter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}TMeter>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 268:
            // Grammar: ID=268; read/write bits=2; START (MeterStatus), START (TMeter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterStatus, meterStatusType (short)); next=269

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 269;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}MeterStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TMeter, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &MeterInfoType->TMeter);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, MeterInfoType->TMeter);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->TMeter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}TMeter>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 269:
            // Grammar: ID=269; read/write bits=2; START (TMeter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (TMeter, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}TMeter");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &MeterInfoType->TMeter);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, MeterInfoType->TMeter);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->TMeter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}TMeter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameterType; base type=EVChargeParameterType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); EAmount, PhysicalValueType (1, 1); EVMaxVoltage, PhysicalValueType (1, 1); EVMaxCurrent, PhysicalValueType (1, 1); EVMinCurrent, PhysicalValueType (1, 1);
static int decode_iso2_AC_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_AC_EVChargeParameterType* AC_EVChargeParameterType, char* xmlOut) {
    int grammar_id = 270;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_AC_EVChargeParameterType(AC_EVChargeParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 270:
            // Grammar: ID=270; read/write bits=2; START (DepartureTime), START (EAmount)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=271

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &AC_EVChargeParameterType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", AC_EVChargeParameterType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        AC_EVChargeParameterType->DepartureTime_isUsed = 1u;
                        grammar_id = 271;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EAmount, PhysicalValueType (PhysicalValueType)); next=272

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EAmount");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EAmount");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVChargeParameterType->EAmount, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 272;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EAmount>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 271:
            // Grammar: ID=271; read/write bits=1; START (EAmount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EAmount, PhysicalValueType (PhysicalValueType)); next=272

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EAmount");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EAmount");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVChargeParameterType->EAmount, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 272;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EAmount>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 272:
            // Grammar: ID=272; read/write bits=1; START (EVMaxVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaxVoltage, PhysicalValueType (PhysicalValueType)); next=273

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaxVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaxVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVChargeParameterType->EVMaxVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 273;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaxVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 273:
            // Grammar: ID=273; read/write bits=1; START (EVMaxCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaxCurrent, PhysicalValueType (PhysicalValueType)); next=274

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaxCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaxCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVChargeParameterType->EVMaxCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 274;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaxCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 274:
            // Grammar: ID=274; read/write bits=1; START (EVMinCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMinCurrent, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMinCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMinCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVChargeParameterType->EVMinCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMinCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameterType; base type=EVChargeParameterType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); DC_EVStatus, DC_EVStatusType (1, 1); EVMaximumCurrentLimit, PhysicalValueType (1, 1); EVMaximumPowerLimit, PhysicalValueType (0, 1); EVMaximumVoltageLimit, PhysicalValueType (1, 1); EVEnergyCapacity, PhysicalValueType (0, 1); EVEnergyRequest, PhysicalValueType (0, 1); FullSOC, percentValueType (0, 1); BulkSOC, percentValueType (0, 1);
static int decode_iso2_DC_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_DC_EVChargeParameterType* DC_EVChargeParameterType, char* xmlOut) {
    int grammar_id = 275;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DC_EVChargeParameterType(DC_EVChargeParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 275:
            // Grammar: ID=275; read/write bits=2; START (DepartureTime), START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=276

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DC_EVChargeParameterType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", DC_EVChargeParameterType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        DC_EVChargeParameterType->DepartureTime_isUsed = 1u;
                        grammar_id = 276;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=277

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &DC_EVChargeParameterType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 277;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 276:
            // Grammar: ID=276; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=277

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &DC_EVChargeParameterType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 277;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 277:
            // Grammar: ID=277; read/write bits=1; START (EVMaximumCurrentLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=278

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 278;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumCurrentLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 278:
            // Grammar: ID=278; read/write bits=2; START (EVMaximumPowerLimit), START (EVMaximumVoltageLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=279

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        DC_EVChargeParameterType->EVMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 279;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumPowerLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMaximumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=280

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVMaximumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 280;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 279:
            // Grammar: ID=279; read/write bits=1; START (EVMaximumVoltageLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=280

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVMaximumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 280;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVMaximumVoltageLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 280:
            // Grammar: ID=280; read/write bits=3; START (EVEnergyCapacity), START (EVEnergyRequest), START (FullSOC), START (BulkSOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVEnergyCapacity, PhysicalValueType (PhysicalValueType)); next=281

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyCapacity");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyCapacity");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVEnergyCapacity, xmlOut);
                    if (error == 0)
                    {
                        DC_EVChargeParameterType->EVEnergyCapacity_isUsed = 1u;
                        grammar_id = 281;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyCapacity>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVEnergyRequest, PhysicalValueType (PhysicalValueType)); next=282

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVEnergyRequest, xmlOut);
                    if (error == 0)
                    {
                        DC_EVChargeParameterType->EVEnergyRequest_isUsed = 1u;
                        grammar_id = 282;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (FullSOC, percentValueType (byte)); next=283

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->FullSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->FullSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->FullSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 283;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FullSOC>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (BulkSOC, percentValueType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->BulkSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->BulkSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->BulkSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 281:
            // Grammar: ID=281; read/write bits=3; START (EVEnergyRequest), START (FullSOC), START (BulkSOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVEnergyRequest, PhysicalValueType (PhysicalValueType)); next=282

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVChargeParameterType->EVEnergyRequest, xmlOut);
                    if (error == 0)
                    {
                        DC_EVChargeParameterType->EVEnergyRequest_isUsed = 1u;
                        grammar_id = 282;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (FullSOC, percentValueType (byte)); next=283

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->FullSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->FullSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->FullSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 283;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FullSOC>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (BulkSOC, percentValueType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->BulkSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->BulkSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->BulkSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 282:
            // Grammar: ID=282; read/write bits=2; START (FullSOC), START (BulkSOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (FullSOC, percentValueType (byte)); next=283

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FullSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->FullSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->FullSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->FullSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 283;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FullSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (BulkSOC, percentValueType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->BulkSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->BulkSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->BulkSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 283:
            // Grammar: ID=283; read/write bits=2; START (BulkSOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (BulkSOC, percentValueType (byte)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DC_EVChargeParameterType->BulkSOC = (int8_t)value;
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", DC_EVChargeParameterType->BulkSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                DC_EVChargeParameterType->BulkSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}BulkSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}EVChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}EVChargeParameterType; base type=; content type=ELEMENT-ONLY;
//          abstract=True; final=False;
// Particle: DepartureTime, unsignedInt (0, 1); AC_EVChargeParameter, AC_EVChargeParameterType (1, 1); DC_EVChargeParameter, DC_EVChargeParameterType (1, 1);
static int decode_iso2_EVChargeParameterType(exi_bitstream_t* stream, struct iso2_EVChargeParameterType* EVChargeParameterType, char* xmlOut) {
    int grammar_id = 284;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_EVChargeParameterType(EVChargeParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 284:
            // Grammar: ID=284; read/write bits=2; START (DepartureTime), START (AC_EVChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=285

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &EVChargeParameterType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", EVChargeParameterType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        EVChargeParameterType->DepartureTime_isUsed = 1u;
                        grammar_id = 285;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DepartureTime>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AC_EVChargeParameter, AC_EVChargeParameterType (EVChargeParameterType)); next=286

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    // decode: element
                    error = decode_iso2_AC_EVChargeParameterType(stream, &EVChargeParameterType->AC_EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 286;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 285:
            // Grammar: ID=285; read/write bits=1; START (AC_EVChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVChargeParameter, AC_EVChargeParameterType (EVChargeParameterType)); next=286

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    // decode: element
                    error = decode_iso2_AC_EVChargeParameterType(stream, &EVChargeParameterType->AC_EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 286;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 286:
            // Grammar: ID=286; read/write bits=1; START (DC_EVChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVChargeParameter, DC_EVChargeParameterType (EVChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter");
                    // decode: element
                    error = decode_iso2_DC_EVChargeParameterType(stream, &EVChargeParameterType->DC_EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SASchedules; type={urn:iso:15118:2:2013:MsgDataTypes}SASchedulesType; base type=; content type=empty;
//          abstract=True; final=False;
static int decode_iso2_SASchedulesType(exi_bitstream_t* stream, struct iso2_SASchedulesType* SASchedulesType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)SASchedulesType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}SAScheduleList; type={urn:iso:15118:2:2013:MsgDataTypes}SAScheduleListType; base type=SASchedulesType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: SAScheduleTuple, SAScheduleTupleType (1, 3);
static int decode_iso2_SAScheduleListType(exi_bitstream_t* stream, struct iso2_SAScheduleListType* SAScheduleListType, char* xmlOut) {
    int grammar_id = 287;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SAScheduleListType(SAScheduleListType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 287:
            // Grammar: ID=287; read/write bits=1; START (SAScheduleTuple)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTuple, SAScheduleTupleType (SAScheduleTupleType)); next=288

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    // decode: element array
                    if (SAScheduleListType->SAScheduleTuple.arrayLen < iso2_SAScheduleTupleType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_SAScheduleTupleType(stream, &SAScheduleListType->SAScheduleTuple.array[SAScheduleListType->SAScheduleTuple.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 288;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 288:
            // Grammar: ID=288; read/write bits=2; START (SAScheduleTuple), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTuple, SAScheduleTupleType (SAScheduleTupleType)); next=289

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    // decode: element array
                    if (SAScheduleListType->SAScheduleTuple.arrayLen < iso2_SAScheduleTupleType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_SAScheduleTupleType(stream, &SAScheduleListType->SAScheduleTuple.array[SAScheduleListType->SAScheduleTuple.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 289;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 289:
            // Grammar: ID=289; read/write bits=2; START (SAScheduleTuple), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTuple, SAScheduleTupleType (SAScheduleTupleType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple");
                    // decode: element array
                    if (SAScheduleListType->SAScheduleTuple.arrayLen < iso2_SAScheduleTupleType_3_ARRAY_SIZE)
                    {

                        error = decode_iso2_SAScheduleTupleType(stream, &SAScheduleListType->SAScheduleTuple.array[SAScheduleListType->SAScheduleTuple.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleTuple>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceParameterList; type={urn:iso:15118:2:2013:MsgDataTypes}ServiceParameterListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ParameterSet, ParameterSetType (1, 21);
static int decode_iso2_ServiceParameterListType(exi_bitstream_t* stream, struct iso2_ServiceParameterListType* ServiceParameterListType, char* xmlOut) {
    int grammar_id = 290;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceParameterListType(ServiceParameterListType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 290:
            // Grammar: ID=290; read/write bits=1; START (ParameterSet)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=291

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 291;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 291:
            // Grammar: ID=291; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=292

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 292;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 292:
            // Grammar: ID=292; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=293

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 293;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 293:
            // Grammar: ID=293; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=294

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 294;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 294:
            // Grammar: ID=294; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=295

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 295;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 295:
            // Grammar: ID=295; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=296

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 296;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 296:
            // Grammar: ID=296; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=297

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 297;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 297:
            // Grammar: ID=297; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=298

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 298;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 298:
            // Grammar: ID=298; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=299

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 299;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 299:
            // Grammar: ID=299; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=300

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 300;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 300:
            // Grammar: ID=300; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=301

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 301;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 301:
            // Grammar: ID=301; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=302

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 302;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 302:
            // Grammar: ID=302; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=303

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 303;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 303:
            // Grammar: ID=303; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=304

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 304;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 304:
            // Grammar: ID=304; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=305

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 305;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 305:
            // Grammar: ID=305; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=306

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 306;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 306:
            // Grammar: ID=306; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=307

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 307;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 307:
            // Grammar: ID=307; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=308

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 308;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 308:
            // Grammar: ID=308; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=309

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 309;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 309:
            // Grammar: ID=309; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=310

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 310;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 310:
            // Grammar: ID=310; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=311

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 311;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 311:
            // Grammar: ID=311; read/write bits=2; START (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso2_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso2_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargeService; type={urn:iso:15118:2:2013:MsgDataTypes}ChargeServiceType; base type=ServiceType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ServiceID, serviceIDType (1, 1); ServiceName, serviceNameType (0, 1); ServiceCategory, serviceCategoryType (1, 1); ServiceScope, serviceScopeType (0, 1); FreeService, boolean (1, 1); SupportedEnergyTransferMode, SupportedEnergyTransferModeType (1, 1);
static int decode_iso2_ChargeServiceType(exi_bitstream_t* stream, struct iso2_ChargeServiceType* ChargeServiceType, char* xmlOut) {
    int grammar_id = 312;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ChargeServiceType(ChargeServiceType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 312:
            // Grammar: ID=312; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=313

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ChargeServiceType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ChargeServiceType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 313;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 313:
            // Grammar: ID=313; read/write bits=2; START (ServiceName), START (ServiceCategory)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceName, serviceNameType (string)); next=314

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceName");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ChargeServiceType->ServiceName.charactersLen);
                            if (error == 0)
                            {
                                if (ChargeServiceType->ServiceName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ChargeServiceType->ServiceName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ChargeServiceType->ServiceName.charactersLen, ChargeServiceType->ServiceName.characters, iso2_ServiceName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ChargeServiceType->ServiceName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ChargeServiceType->ServiceName.characters[i]))
                                        {
                                            ChargeServiceType->ServiceName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ChargeServiceType->ServiceName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ChargeServiceType->ServiceName_isUsed = 1u;
                                grammar_id = 314;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceName>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=315

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ChargeServiceType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 315;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 314:
            // Grammar: ID=314; read/write bits=1; START (ServiceCategory)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=315

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ChargeServiceType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 315;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceCategory>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 315:
            // Grammar: ID=315; read/write bits=2; START (ServiceScope), START (FreeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceScope, serviceScopeType (string)); next=316

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ChargeServiceType->ServiceScope.charactersLen);
                            if (error == 0)
                            {
                                if (ChargeServiceType->ServiceScope.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ChargeServiceType->ServiceScope.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ChargeServiceType->ServiceScope.charactersLen, ChargeServiceType->ServiceScope.characters, iso2_ServiceScope_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ChargeServiceType->ServiceScope.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ChargeServiceType->ServiceScope.characters[i]))
                                        {
                                            ChargeServiceType->ServiceScope.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ChargeServiceType->ServiceScope.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ChargeServiceType->ServiceScope_isUsed = 1u;
                                grammar_id = 316;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ServiceScope>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (FreeService, boolean (boolean)); next=317

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ChargeServiceType->FreeService = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 317;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FreeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 316:
            // Grammar: ID=316; read/write bits=1; START (FreeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (FreeService, boolean (boolean)); next=317

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}FreeService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ChargeServiceType->FreeService = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 317;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}FreeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 317:
            // Grammar: ID=317; read/write bits=1; START (SupportedEnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SupportedEnergyTransferMode, SupportedEnergyTransferModeType (SupportedEnergyTransferModeType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SupportedEnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SupportedEnergyTransferMode");
                    // decode: element
                    error = decode_iso2_SupportedEnergyTransferModeType(stream, &ChargeServiceType->SupportedEnergyTransferMode, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SupportedEnergyTransferMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey; type={urn:iso:15118:2:2013:MsgDataTypes}ContractSignatureEncryptedPrivateKeyType; base type=privateKeyType; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (1, 1); CONTENT, ContractSignatureEncryptedPrivateKeyType (1, 1);
static int decode_iso2_ContractSignatureEncryptedPrivateKeyType(exi_bitstream_t* stream, struct iso2_ContractSignatureEncryptedPrivateKeyType* ContractSignatureEncryptedPrivateKeyType, char* xmlOut) {
    int grammar_id = 318;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ContractSignatureEncryptedPrivateKeyType(ContractSignatureEncryptedPrivateKeyType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 318:
            // Grammar: ID=318; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=319

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ContractSignatureEncryptedPrivateKeyType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ContractSignatureEncryptedPrivateKeyType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ContractSignatureEncryptedPrivateKeyType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ContractSignatureEncryptedPrivateKeyType->Id.charactersLen, ContractSignatureEncryptedPrivateKeyType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < ContractSignatureEncryptedPrivateKeyType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ContractSignatureEncryptedPrivateKeyType->Id.characters[i]))
                                {
                                    ContractSignatureEncryptedPrivateKeyType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ContractSignatureEncryptedPrivateKeyType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 319;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 319:
            // Grammar: ID=319; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (CONTENT, ContractSignatureEncryptedPrivateKeyType (base64Binary)); next=3
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen, &ContractSignatureEncryptedPrivateKeyType->CONTENT.bytes[0], iso2_ContractSignatureEncryptedPrivateKeyType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen ? (unsigned char) ContractSignatureEncryptedPrivateKeyType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen ? (unsigned char) ContractSignatureEncryptedPrivateKeyType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen ? (unsigned char) ContractSignatureEncryptedPrivateKeyType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ContractSignatureEncryptedPrivateKeyType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 3;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}EVPowerDeliveryParameter; type={urn:iso:15118:2:2013:MsgDataTypes}EVPowerDeliveryParameterType; base type=; content type=empty;
//          abstract=True; final=False;
static int decode_iso2_EVPowerDeliveryParameterType(exi_bitstream_t* stream, struct iso2_EVPowerDeliveryParameterType* EVPowerDeliveryParameterType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)EVPowerDeliveryParameterType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter; type={urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameterType; base type=EVPowerDeliveryParameterType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVStatus, DC_EVStatusType (1, 1); BulkChargingComplete, boolean (0, 1); ChargingComplete, boolean (1, 1);
static int decode_iso2_DC_EVPowerDeliveryParameterType(exi_bitstream_t* stream, struct iso2_DC_EVPowerDeliveryParameterType* DC_EVPowerDeliveryParameterType, char* xmlOut) {
    int grammar_id = 320;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DC_EVPowerDeliveryParameterType(DC_EVPowerDeliveryParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 320:
            // Grammar: ID=320; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=321

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &DC_EVPowerDeliveryParameterType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 321;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 321:
            // Grammar: ID=321; read/write bits=2; START (BulkChargingComplete), START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (BulkChargingComplete, boolean (boolean)); next=322

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}BulkChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}BulkChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DC_EVPowerDeliveryParameterType->BulkChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                DC_EVPowerDeliveryParameterType->BulkChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 322;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}BulkChargingComplete>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DC_EVPowerDeliveryParameterType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 322:
            // Grammar: ID=322; read/write bits=1; START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DC_EVPowerDeliveryParameterType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}EVSEChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}EVSEChargeParameterType; base type=; content type=empty;
//          abstract=True; final=False;
static int decode_iso2_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_EVSEChargeParameterType* EVSEChargeParameterType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)EVSEChargeParameterType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameterType; base type=EVSEChargeParameterType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: AC_EVSEStatus, AC_EVSEStatusType (1, 1); EVSENominalVoltage, PhysicalValueType (1, 1); EVSEMaxCurrent, PhysicalValueType (1, 1);
static int decode_iso2_AC_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_AC_EVSEChargeParameterType* AC_EVSEChargeParameterType, char* xmlOut) {
    int grammar_id = 323;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_AC_EVSEChargeParameterType(AC_EVSEChargeParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 323:
            // Grammar: ID=323; read/write bits=1; START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=324

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &AC_EVSEChargeParameterType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 324;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 324:
            // Grammar: ID=324; read/write bits=1; START (EVSENominalVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSENominalVoltage, PhysicalValueType (PhysicalValueType)); next=325

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSENominalVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSENominalVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVSEChargeParameterType->EVSENominalVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 325;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSENominalVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 325:
            // Grammar: ID=325; read/write bits=1; START (EVSEMaxCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaxCurrent, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaxCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaxCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &AC_EVSEChargeParameterType->EVSEMaxCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaxCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter; type={urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameterType; base type=EVSEChargeParameterType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVSEStatus, DC_EVSEStatusType (1, 1); EVSEMaximumCurrentLimit, PhysicalValueType (1, 1); EVSEMaximumPowerLimit, PhysicalValueType (1, 1); EVSEMaximumVoltageLimit, PhysicalValueType (1, 1); EVSEMinimumCurrentLimit, PhysicalValueType (1, 1); EVSEMinimumVoltageLimit, PhysicalValueType (1, 1); EVSECurrentRegulationTolerance, PhysicalValueType (0, 1); EVSEPeakCurrentRipple, PhysicalValueType (1, 1); EVSEEnergyToBeDelivered, PhysicalValueType (0, 1);
static int decode_iso2_DC_EVSEChargeParameterType(exi_bitstream_t* stream, struct iso2_DC_EVSEChargeParameterType* DC_EVSEChargeParameterType, char* xmlOut) {
    int grammar_id = 326;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DC_EVSEChargeParameterType(DC_EVSEChargeParameterType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 326:
            // Grammar: ID=326; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=327

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &DC_EVSEChargeParameterType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 327;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 327:
            // Grammar: ID=327; read/write bits=1; START (EVSEMaximumCurrentLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=328

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 328;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumCurrentLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 328:
            // Grammar: ID=328; read/write bits=1; START (EVSEMaximumPowerLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=329

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 329;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumPowerLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 329:
            // Grammar: ID=329; read/write bits=1; START (EVSEMaximumVoltageLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=330

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEMaximumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 330;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMaximumVoltageLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 330:
            // Grammar: ID=330; read/write bits=1; START (EVSEMinimumCurrentLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMinimumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=331

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEMinimumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 331;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumCurrentLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 331:
            // Grammar: ID=331; read/write bits=1; START (EVSEMinimumVoltageLimit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMinimumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=332

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEMinimumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 332;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEMinimumVoltageLimit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 332:
            // Grammar: ID=332; read/write bits=2; START (EVSECurrentRegulationTolerance), START (EVSEPeakCurrentRipple)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSECurrentRegulationTolerance, PhysicalValueType (PhysicalValueType)); next=333

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSECurrentRegulationTolerance");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSECurrentRegulationTolerance");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSECurrentRegulationTolerance, xmlOut);
                    if (error == 0)
                    {
                        DC_EVSEChargeParameterType->EVSECurrentRegulationTolerance_isUsed = 1u;
                        grammar_id = 333;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSECurrentRegulationTolerance>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVSEPeakCurrentRipple, PhysicalValueType (PhysicalValueType)); next=334

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEPeakCurrentRipple, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 334;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 333:
            // Grammar: ID=333; read/write bits=1; START (EVSEPeakCurrentRipple)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPeakCurrentRipple, PhysicalValueType (PhysicalValueType)); next=334

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEPeakCurrentRipple, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 334;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEPeakCurrentRipple>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 334:
            // Grammar: ID=334; read/write bits=2; START (EVSEEnergyToBeDelivered), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEEnergyToBeDelivered, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}EVSEEnergyToBeDelivered");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}EVSEEnergyToBeDelivered");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &DC_EVSEChargeParameterType->EVSEEnergyToBeDelivered, xmlOut);
                    if (error == 0)
                    {
                        DC_EVSEChargeParameterType->EVSEEnergyToBeDelivered_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}EVSEEnergyToBeDelivered>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceList; type={urn:iso:15118:2:2013:MsgDataTypes}ServiceListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Service, ServiceType (1, 8);
static int decode_iso2_ServiceListType(exi_bitstream_t* stream, struct iso2_ServiceListType* ServiceListType, char* xmlOut) {
    int grammar_id = 335;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceListType(ServiceListType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 335:
            // Grammar: ID=335; read/write bits=1; START (Service)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=336

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 336;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 336:
            // Grammar: ID=336; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=337

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 337;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 337:
            // Grammar: ID=337; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=338

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 338;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 338:
            // Grammar: ID=338; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=339

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 339;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 339:
            // Grammar: ID=339; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=340

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 340;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 340:
            // Grammar: ID=340; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=341

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 341;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 341:
            // Grammar: ID=341; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=342

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 342;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 342:
            // Grammar: ID=342; read/write bits=2; START (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso2_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso2_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut);
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 3;

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}DHpublickey; type={urn:iso:15118:2:2013:MsgDataTypes}DiffieHellmanPublickeyType; base type=dHpublickeyType; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (1, 1); CONTENT, DiffieHellmanPublickeyType (1, 1);
static int decode_iso2_DiffieHellmanPublickeyType(exi_bitstream_t* stream, struct iso2_DiffieHellmanPublickeyType* DiffieHellmanPublickeyType, char* xmlOut) {
    int grammar_id = 343;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_DiffieHellmanPublickeyType(DiffieHellmanPublickeyType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 343:
            // Grammar: ID=343; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=344

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &DiffieHellmanPublickeyType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (DiffieHellmanPublickeyType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            DiffieHellmanPublickeyType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, DiffieHellmanPublickeyType->Id.charactersLen, DiffieHellmanPublickeyType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < DiffieHellmanPublickeyType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(DiffieHellmanPublickeyType->Id.characters[i]))
                                {
                                    DiffieHellmanPublickeyType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, DiffieHellmanPublickeyType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 344;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 344:
            // Grammar: ID=344; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (CONTENT, DiffieHellmanPublickeyType (base64Binary)); next=3
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &DiffieHellmanPublickeyType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, DiffieHellmanPublickeyType->CONTENT.bytesLen, &DiffieHellmanPublickeyType->CONTENT.bytes[0], iso2_DiffieHellmanPublickeyType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DiffieHellmanPublickeyType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DiffieHellmanPublickeyType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < DiffieHellmanPublickeyType->CONTENT.bytesLen ? (unsigned char) DiffieHellmanPublickeyType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < DiffieHellmanPublickeyType->CONTENT.bytesLen ? (unsigned char) DiffieHellmanPublickeyType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < DiffieHellmanPublickeyType->CONTENT.bytesLen ? (unsigned char) DiffieHellmanPublickeyType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DiffieHellmanPublickeyType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 3;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}eMAID; type={urn:iso:15118:2:2013:MsgDataTypes}EMAIDType; base type=eMAIDType; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (1, 1); CONTENT, EMAIDType (1, 1);
static int decode_iso2_EMAIDType(exi_bitstream_t* stream, struct iso2_EMAIDType* EMAIDType, char* xmlOut) {
    int grammar_id = 345;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_EMAIDType(EMAIDType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 345:
            // Grammar: ID=345; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=346

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgDataTypes}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &EMAIDType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (EMAIDType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            EMAIDType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, EMAIDType->Id.charactersLen, EMAIDType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < EMAIDType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(EMAIDType->Id.characters[i]))
                                {
                                    EMAIDType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, EMAIDType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 346;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 346:
            // Grammar: ID=346; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (CONTENT, EMAIDType (string)); next=3
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_uint_16(stream, &EMAIDType->CONTENT.charactersLen);
                    if (error == 0)
                    {
                        if (EMAIDType->CONTENT.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            EMAIDType->CONTENT.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, EMAIDType->CONTENT.charactersLen, EMAIDType->CONTENT.characters, iso2_CONTENT_CHARACTER_SIZE);
                            strcat(xmlOut, ">");
                            for(int i = 0; i < EMAIDType->CONTENT.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(EMAIDType->CONTENT.characters[i]))
                                {
                                    EMAIDType->CONTENT.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, EMAIDType->CONTENT.characters);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDef}Header; type={urn:iso:15118:2:2013:MsgHeader}MessageHeaderType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SessionID, sessionIDType (1, 1); Notification, NotificationType (0, 1); Signature, SignatureType (0, 1);
static int decode_iso2_MessageHeaderType(exi_bitstream_t* stream, struct iso2_MessageHeaderType* MessageHeaderType, char* xmlOut) {
    int grammar_id = 347;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_MessageHeaderType(MessageHeaderType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 347:
            // Grammar: ID=347; read/write bits=1; START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=348

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgHeader}SessionID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgHeader}SessionID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &MessageHeaderType->SessionID.bytesLen, &MessageHeaderType->SessionID.bytes[0], iso2_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &MessageHeaderType->SessionID.bytes[0];
                        uint16_t len = MessageHeaderType->SessionID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 348;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgHeader}SessionID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 348:
            // Grammar: ID=348; read/write bits=2; START (Notification), START (Signature), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Notification, NotificationType (NotificationType)); next=349

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgHeader}Notification");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgHeader}Notification");
                    // decode: element
                    error = decode_iso2_NotificationType(stream, &MessageHeaderType->Notification, xmlOut);
                    if (error == 0)
                    {
                        MessageHeaderType->Notification_isUsed = 1u;
                        grammar_id = 349;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgHeader}Notification>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Signature, SignatureType (SignatureType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    // decode: element
                    error = decode_iso2_SignatureType(stream, &MessageHeaderType->Signature, xmlOut);
                    if (error == 0)
                    {
                        MessageHeaderType->Signature_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Signature>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 349:
            // Grammar: ID=349; read/write bits=2; START (Signature), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Signature, SignatureType (SignatureType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    // decode: element
                    error = decode_iso2_SignatureType(stream, &MessageHeaderType->Signature, xmlOut);
                    if (error == 0)
                    {
                        MessageHeaderType->Signature_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Signature>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CertificateUpdateReq; type={urn:iso:15118:2:2013:MsgBody}CertificateUpdateReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (1, 1); ContractSignatureCertChain, CertificateChainType (1, 1); eMAID, eMAIDType (1, 1); ListOfRootCertificateIDs, ListOfRootCertificateIDsType (1, 1);
static int decode_iso2_CertificateUpdateReqType(exi_bitstream_t* stream, struct iso2_CertificateUpdateReqType* CertificateUpdateReqType, char* xmlOut) {
    int grammar_id = 350;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CertificateUpdateReqType(CertificateUpdateReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 350:
            // Grammar: ID=350; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=351

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgBody}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CertificateUpdateReqType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (CertificateUpdateReqType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CertificateUpdateReqType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CertificateUpdateReqType->Id.charactersLen, CertificateUpdateReqType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < CertificateUpdateReqType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(CertificateUpdateReqType->Id.characters[i]))
                                {
                                    CertificateUpdateReqType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, CertificateUpdateReqType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 351;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 351:
            // Grammar: ID=351; read/write bits=1; START (ContractSignatureCertChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureCertChain, CertificateChainType (CertificateChainType)); next=352

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &CertificateUpdateReqType->ContractSignatureCertChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 352;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 352:
            // Grammar: ID=352; read/write bits=1; START (eMAID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (eMAID, eMAIDType (string)); next=353

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &CertificateUpdateReqType->eMAID.charactersLen);
                            if (error == 0)
                            {
                                if (CertificateUpdateReqType->eMAID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    CertificateUpdateReqType->eMAID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, CertificateUpdateReqType->eMAID.charactersLen, CertificateUpdateReqType->eMAID.characters, iso2_eMAID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < CertificateUpdateReqType->eMAID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(CertificateUpdateReqType->eMAID.characters[i]))
                                        {
                                            CertificateUpdateReqType->eMAID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, CertificateUpdateReqType->eMAID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 353;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}eMAID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 353:
            // Grammar: ID=353; read/write bits=1; START (ListOfRootCertificateIDs)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ListOfRootCertificateIDs, ListOfRootCertificateIDsType (ListOfRootCertificateIDsType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs");
                    // decode: element
                    error = decode_iso2_ListOfRootCertificateIDsType(stream, &CertificateUpdateReqType->ListOfRootCertificateIDs, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceDetailReq; type={urn:iso:15118:2:2013:MsgBody}ServiceDetailReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ServiceID, serviceIDType (1, 1);
static int decode_iso2_ServiceDetailReqType(exi_bitstream_t* stream, struct iso2_ServiceDetailReqType* ServiceDetailReqType, char* xmlOut) {
    int grammar_id = 354;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceDetailReqType(ServiceDetailReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 354:
            // Grammar: ID=354; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceDetailReqType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ServiceDetailReqType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}WeldingDetectionRes; type={urn:iso:15118:2:2013:MsgBody}WeldingDetectionResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); DC_EVSEStatus, DC_EVSEStatusType (1, 1); EVSEPresentVoltage, PhysicalValueType (1, 1);
static int decode_iso2_WeldingDetectionResType(exi_bitstream_t* stream, struct iso2_WeldingDetectionResType* WeldingDetectionResType, char* xmlOut) {
    int grammar_id = 355;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_WeldingDetectionResType(WeldingDetectionResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 355:
            // Grammar: ID=355; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=356

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                WeldingDetectionResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 356;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 356:
            // Grammar: ID=356; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=357

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &WeldingDetectionResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 357;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 357:
            // Grammar: ID=357; read/write bits=1; START (EVSEPresentVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPresentVoltage, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &WeldingDetectionResType->EVSEPresentVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}AuthorizationReq; type={urn:iso:15118:2:2013:MsgBody}AuthorizationReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); GenChallenge, genChallengeType (0, 1);
static int decode_iso2_AuthorizationReqType(exi_bitstream_t* stream, struct iso2_AuthorizationReqType* AuthorizationReqType, char* xmlOut) {
    int grammar_id = 358;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_AuthorizationReqType(AuthorizationReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 358:
            // Grammar: ID=358; read/write bits=2; START (Id), START (GenChallenge), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=359

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgBody}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &AuthorizationReqType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (AuthorizationReqType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            AuthorizationReqType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, AuthorizationReqType->Id.charactersLen, AuthorizationReqType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < AuthorizationReqType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(AuthorizationReqType->Id.characters[i]))
                                {
                                    AuthorizationReqType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, AuthorizationReqType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    AuthorizationReqType->Id_isUsed = 1u;
                    grammar_id = 359;

                    }
                    break;
                case 1:
                    {
                    // Event: START (GenChallenge, genChallengeType (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &AuthorizationReqType->GenChallenge.bytesLen, &AuthorizationReqType->GenChallenge.bytes[0], iso2_genChallengeType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((AuthorizationReqType->GenChallenge.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < AuthorizationReqType->GenChallenge.bytesLen;) {
                            uint32_t octet_a = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_b = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_c = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[AuthorizationReqType->GenChallenge.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        AuthorizationReqType->GenChallenge_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}GenChallenge>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 359:
            // Grammar: ID=359; read/write bits=2; START (GenChallenge), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (GenChallenge, genChallengeType (base64Binary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &AuthorizationReqType->GenChallenge.bytesLen, &AuthorizationReqType->GenChallenge.bytes[0], iso2_genChallengeType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((AuthorizationReqType->GenChallenge.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < AuthorizationReqType->GenChallenge.bytesLen;) {
                            uint32_t octet_a = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_b = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_c = i < AuthorizationReqType->GenChallenge.bytesLen ? (unsigned char) AuthorizationReqType->GenChallenge.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[AuthorizationReqType->GenChallenge.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        AuthorizationReqType->GenChallenge_isUsed = 1u;
                        grammar_id = 3;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}GenChallenge>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PaymentDetailsRes; type={urn:iso:15118:2:2013:MsgBody}PaymentDetailsResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); GenChallenge, genChallengeType (1, 1); EVSETimeStamp, long (1, 1);
static int decode_iso2_PaymentDetailsResType(exi_bitstream_t* stream, struct iso2_PaymentDetailsResType* PaymentDetailsResType, char* xmlOut) {
    int grammar_id = 360;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PaymentDetailsResType(PaymentDetailsResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 360:
            // Grammar: ID=360; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=361

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                PaymentDetailsResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 361;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 361:
            // Grammar: ID=361; read/write bits=1; START (GenChallenge)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (GenChallenge, genChallengeType (base64Binary)); next=362

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}GenChallenge");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PaymentDetailsResType->GenChallenge.bytesLen, &PaymentDetailsResType->GenChallenge.bytes[0], iso2_genChallengeType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PaymentDetailsResType->GenChallenge.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PaymentDetailsResType->GenChallenge.bytesLen;) {
                            uint32_t octet_a = i < PaymentDetailsResType->GenChallenge.bytesLen ? (unsigned char) PaymentDetailsResType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_b = i < PaymentDetailsResType->GenChallenge.bytesLen ? (unsigned char) PaymentDetailsResType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_c = i < PaymentDetailsResType->GenChallenge.bytesLen ? (unsigned char) PaymentDetailsResType->GenChallenge.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PaymentDetailsResType->GenChallenge.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 362;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}GenChallenge>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 362:
            // Grammar: ID=362; read/write bits=1; START (EVSETimeStamp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSETimeStamp, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &PaymentDetailsResType->EVSETimeStamp);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, PaymentDetailsResType->EVSETimeStamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}SessionStopReq; type={urn:iso:15118:2:2013:MsgBody}SessionStopReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ChargingSession, chargingSessionType (1, 1);
static int decode_iso2_SessionStopReqType(exi_bitstream_t* stream, struct iso2_SessionStopReqType* SessionStopReqType, char* xmlOut) {
    int grammar_id = 363;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SessionStopReqType(SessionStopReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 363:
            // Grammar: ID=363; read/write bits=1; START (ChargingSession)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingSession, chargingSessionType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingSession");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingSession");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                SessionStopReqType->ChargingSession = (iso2_chargingSessionType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_chargingSessionType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingSession>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CertificateUpdateRes; type={urn:iso:15118:2:2013:MsgBody}CertificateUpdateResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); SAProvisioningCertificateChain, CertificateChainType (1, 1); ContractSignatureCertChain, CertificateChainType (1, 1); ContractSignatureEncryptedPrivateKey, ContractSignatureEncryptedPrivateKeyType (1, 1); DHpublickey, DiffieHellmanPublickeyType (1, 1); eMAID, EMAIDType (1, 1); RetryCounter, short (0, 1);
static int decode_iso2_CertificateUpdateResType(exi_bitstream_t* stream, struct iso2_CertificateUpdateResType* CertificateUpdateResType, char* xmlOut) {
    int grammar_id = 364;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CertificateUpdateResType(CertificateUpdateResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 364:
            // Grammar: ID=364; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=365

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                CertificateUpdateResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 365;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 365:
            // Grammar: ID=365; read/write bits=1; START (SAProvisioningCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAProvisioningCertificateChain, CertificateChainType (CertificateChainType)); next=366

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &CertificateUpdateResType->SAProvisioningCertificateChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 366;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 366:
            // Grammar: ID=366; read/write bits=1; START (ContractSignatureCertChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureCertChain, CertificateChainType (CertificateChainType)); next=367

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &CertificateUpdateResType->ContractSignatureCertChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 367;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 367:
            // Grammar: ID=367; read/write bits=1; START (ContractSignatureEncryptedPrivateKey)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureEncryptedPrivateKey, ContractSignatureEncryptedPrivateKeyType (privateKeyType)); next=368

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey");
                    // decode: element
                    error = decode_iso2_ContractSignatureEncryptedPrivateKeyType(stream, &CertificateUpdateResType->ContractSignatureEncryptedPrivateKey, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 368;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 368:
            // Grammar: ID=368; read/write bits=1; START (DHpublickey)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DHpublickey, DiffieHellmanPublickeyType (dHpublickeyType)); next=369

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DHpublickey");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DHpublickey");
                    // decode: element
                    error = decode_iso2_DiffieHellmanPublickeyType(stream, &CertificateUpdateResType->DHpublickey, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 369;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DHpublickey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 369:
            // Grammar: ID=369; read/write bits=1; START (eMAID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (eMAID, EMAIDType (eMAIDType)); next=370

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    // decode: element
                    error = decode_iso2_EMAIDType(stream, &CertificateUpdateResType->eMAID, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 370;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}eMAID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 370:
            // Grammar: ID=370; read/write bits=2; START (RetryCounter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RetryCounter, short (int)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RetryCounter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RetryCounter");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &CertificateUpdateResType->RetryCounter);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%d", CertificateUpdateResType->RetryCounter);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        CertificateUpdateResType->RetryCounter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RetryCounter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CertificateInstallationRes; type={urn:iso:15118:2:2013:MsgBody}CertificateInstallationResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); SAProvisioningCertificateChain, CertificateChainType (1, 1); ContractSignatureCertChain, CertificateChainType (1, 1); ContractSignatureEncryptedPrivateKey, ContractSignatureEncryptedPrivateKeyType (1, 1); DHpublickey, DiffieHellmanPublickeyType (1, 1); eMAID, EMAIDType (1, 1);
static int decode_iso2_CertificateInstallationResType(exi_bitstream_t* stream, struct iso2_CertificateInstallationResType* CertificateInstallationResType, char* xmlOut) {
    int grammar_id = 371;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CertificateInstallationResType(CertificateInstallationResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 371:
            // Grammar: ID=371; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=372

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                CertificateInstallationResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 372;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 372:
            // Grammar: ID=372; read/write bits=1; START (SAProvisioningCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAProvisioningCertificateChain, CertificateChainType (CertificateChainType)); next=373

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &CertificateInstallationResType->SAProvisioningCertificateChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 373;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAProvisioningCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 373:
            // Grammar: ID=373; read/write bits=1; START (ContractSignatureCertChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureCertChain, CertificateChainType (CertificateChainType)); next=374

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &CertificateInstallationResType->ContractSignatureCertChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 374;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 374:
            // Grammar: ID=374; read/write bits=1; START (ContractSignatureEncryptedPrivateKey)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureEncryptedPrivateKey, ContractSignatureEncryptedPrivateKeyType (privateKeyType)); next=375

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey");
                    // decode: element
                    error = decode_iso2_ContractSignatureEncryptedPrivateKeyType(stream, &CertificateInstallationResType->ContractSignatureEncryptedPrivateKey, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 375;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureEncryptedPrivateKey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 375:
            // Grammar: ID=375; read/write bits=1; START (DHpublickey)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DHpublickey, DiffieHellmanPublickeyType (dHpublickeyType)); next=376

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DHpublickey");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DHpublickey");
                    // decode: element
                    error = decode_iso2_DiffieHellmanPublickeyType(stream, &CertificateInstallationResType->DHpublickey, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 376;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DHpublickey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 376:
            // Grammar: ID=376; read/write bits=1; START (eMAID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (eMAID, EMAIDType (eMAIDType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    // decode: element
                    error = decode_iso2_EMAIDType(stream, &CertificateInstallationResType->eMAID, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}eMAID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CableCheckRes; type={urn:iso:15118:2:2013:MsgBody}CableCheckResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); DC_EVSEStatus, DC_EVSEStatusType (1, 1); EVSEProcessing, EVSEProcessingType (1, 1);
static int decode_iso2_CableCheckResType(exi_bitstream_t* stream, struct iso2_CableCheckResType* CableCheckResType, char* xmlOut) {
    int grammar_id = 377;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CableCheckResType(CableCheckResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 377:
            // Grammar: ID=377; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=378

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                CableCheckResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 378;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 378:
            // Grammar: ID=378; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=379

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &CableCheckResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 379;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 379:
            // Grammar: ID=379; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, EVSEProcessingType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                CableCheckResType->EVSEProcessing = (iso2_EVSEProcessingType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSEProcessingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PowerDeliveryReq; type={urn:iso:15118:2:2013:MsgBody}PowerDeliveryReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ChargeProgress, chargeProgressType (1, 1); SAScheduleTupleID, SAIDType (1, 1); ChargingProfile, ChargingProfileType (0, 1); DC_EVPowerDeliveryParameter, DC_EVPowerDeliveryParameterType (0, 1); EVPowerDeliveryParameter, EVPowerDeliveryParameterType (0, 1);
static int decode_iso2_PowerDeliveryReqType(exi_bitstream_t* stream, struct iso2_PowerDeliveryReqType* PowerDeliveryReqType, char* xmlOut) {
    int grammar_id = 380;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PowerDeliveryReqType(PowerDeliveryReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 380:
            // Grammar: ID=380; read/write bits=1; START (ChargeProgress)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargeProgress, chargeProgressType (string)); next=381

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargeProgress");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargeProgress");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                PowerDeliveryReqType->ChargeProgress = (iso2_chargeProgressType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_chargeProgressType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 381;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargeProgress>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 381:
            // Grammar: ID=381; read/write bits=1; START (SAScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTupleID, SAIDType (unsignedByte)); next=382

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                PowerDeliveryReqType->SAScheduleTupleID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PowerDeliveryReqType->SAScheduleTupleID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 382;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 382:
            // Grammar: ID=382; read/write bits=3; START (ChargingProfile), START (DC_EVPowerDeliveryParameter), START (EVPowerDeliveryParameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingProfile, ChargingProfileType (ChargingProfileType)); next=383

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingProfile");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingProfile");
                    // decode: element
                    error = decode_iso2_ChargingProfileType(stream, &PowerDeliveryReqType->ChargingProfile, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->ChargingProfile_isUsed = 1u;
                        grammar_id = 383;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingProfile>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVPowerDeliveryParameter, DC_EVPowerDeliveryParameterType (EVPowerDeliveryParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter");
                    // decode: element
                    error = decode_iso2_DC_EVPowerDeliveryParameterType(stream, &PowerDeliveryReqType->DC_EVPowerDeliveryParameter, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->DC_EVPowerDeliveryParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter>");
                    }
                    break;
                case 2:
                    {
                    // Abstract element or type: EVPowerDeliveryParameter, EVPowerDeliveryParameterType (EVPowerDeliveryParameterType)
                    // decode: element
                    error = decode_iso2_EVPowerDeliveryParameterType(stream, &PowerDeliveryReqType->EVPowerDeliveryParameter, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->EVPowerDeliveryParameter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 383:
            // Grammar: ID=383; read/write bits=2; START (DC_EVPowerDeliveryParameter), START (EVPowerDeliveryParameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVPowerDeliveryParameter, DC_EVPowerDeliveryParameterType (EVPowerDeliveryParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter");
                    // decode: element
                    error = decode_iso2_DC_EVPowerDeliveryParameterType(stream, &PowerDeliveryReqType->DC_EVPowerDeliveryParameter, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->DC_EVPowerDeliveryParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVPowerDeliveryParameter>");
                    }
                    break;
                case 1:
                    {
                    // Abstract element or type: EVPowerDeliveryParameter, EVPowerDeliveryParameterType (EVPowerDeliveryParameterType)
                    // decode: element
                    error = decode_iso2_EVPowerDeliveryParameterType(stream, &PowerDeliveryReqType->EVPowerDeliveryParameter, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->EVPowerDeliveryParameter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CertificateInstallationReq; type={urn:iso:15118:2:2013:MsgBody}CertificateInstallationReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (1, 1); OEMProvisioningCert, certificateType (1, 1); ListOfRootCertificateIDs, ListOfRootCertificateIDsType (1, 1);
static int decode_iso2_CertificateInstallationReqType(exi_bitstream_t* stream, struct iso2_CertificateInstallationReqType* CertificateInstallationReqType, char* xmlOut) {
    int grammar_id = 384;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CertificateInstallationReqType(CertificateInstallationReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 384:
            // Grammar: ID=384; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=385

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgBody}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CertificateInstallationReqType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (CertificateInstallationReqType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CertificateInstallationReqType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CertificateInstallationReqType->Id.charactersLen, CertificateInstallationReqType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < CertificateInstallationReqType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(CertificateInstallationReqType->Id.characters[i]))
                                {
                                    CertificateInstallationReqType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, CertificateInstallationReqType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 385;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 385:
            // Grammar: ID=385; read/write bits=1; START (OEMProvisioningCert)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (OEMProvisioningCert, certificateType (base64Binary)); next=386

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}OEMProvisioningCert");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}OEMProvisioningCert");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CertificateInstallationReqType->OEMProvisioningCert.bytesLen, &CertificateInstallationReqType->OEMProvisioningCert.bytes[0], iso2_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CertificateInstallationReqType->OEMProvisioningCert.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CertificateInstallationReqType->OEMProvisioningCert.bytesLen;) {
                            uint32_t octet_a = i < CertificateInstallationReqType->OEMProvisioningCert.bytesLen ? (unsigned char) CertificateInstallationReqType->OEMProvisioningCert.bytes[i++] : 0;
                            uint32_t octet_b = i < CertificateInstallationReqType->OEMProvisioningCert.bytesLen ? (unsigned char) CertificateInstallationReqType->OEMProvisioningCert.bytes[i++] : 0;
                            uint32_t octet_c = i < CertificateInstallationReqType->OEMProvisioningCert.bytesLen ? (unsigned char) CertificateInstallationReqType->OEMProvisioningCert.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CertificateInstallationReqType->OEMProvisioningCert.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 386;
                    }




                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}OEMProvisioningCert>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 386:
            // Grammar: ID=386; read/write bits=1; START (ListOfRootCertificateIDs)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ListOfRootCertificateIDs, ListOfRootCertificateIDsType (ListOfRootCertificateIDsType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs");
                    // decode: element
                    error = decode_iso2_ListOfRootCertificateIDsType(stream, &CertificateInstallationReqType->ListOfRootCertificateIDs, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ListOfRootCertificateIDs>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}MeteringReceiptReq; type={urn:iso:15118:2:2013:MsgBody}MeteringReceiptReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); SessionID, sessionIDType (1, 1); SAScheduleTupleID, SAIDType (0, 1); MeterInfo, MeterInfoType (1, 1);
static int decode_iso2_MeteringReceiptReqType(exi_bitstream_t* stream, struct iso2_MeteringReceiptReqType* MeteringReceiptReqType, char* xmlOut) {
    int grammar_id = 387;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_MeteringReceiptReqType(MeteringReceiptReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 387:
            // Grammar: ID=387; read/write bits=2; START (Id), START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=388

                    strcat(xmlOut, " {urn:iso:15118:2:2013:MsgBody}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &MeteringReceiptReqType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (MeteringReceiptReqType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            MeteringReceiptReqType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, MeteringReceiptReqType->Id.charactersLen, MeteringReceiptReqType->Id.characters, iso2_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            for(int i = 0; i < MeteringReceiptReqType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(MeteringReceiptReqType->Id.characters[i]))
                                {
                                    MeteringReceiptReqType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, MeteringReceiptReqType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    MeteringReceiptReqType->Id_isUsed = 1u;
                    grammar_id = 388;

                    }
                    break;
                case 1:
                    {
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=389

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SessionID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SessionID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &MeteringReceiptReqType->SessionID.bytesLen, &MeteringReceiptReqType->SessionID.bytes[0], iso2_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &MeteringReceiptReqType->SessionID.bytes[0];
                        uint16_t len = MeteringReceiptReqType->SessionID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 389;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 388:
            // Grammar: ID=388; read/write bits=1; START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=389

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SessionID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SessionID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &MeteringReceiptReqType->SessionID.bytesLen, &MeteringReceiptReqType->SessionID.bytes[0], iso2_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &MeteringReceiptReqType->SessionID.bytes[0];
                        uint16_t len = MeteringReceiptReqType->SessionID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 389;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 389:
            // Grammar: ID=389; read/write bits=2; START (SAScheduleTupleID), START (MeterInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTupleID, SAIDType (unsignedByte)); next=390

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                MeteringReceiptReqType->SAScheduleTupleID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", MeteringReceiptReqType->SAScheduleTupleID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                MeteringReceiptReqType->SAScheduleTupleID_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 390;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    // decode: element
                    error = decode_iso2_MeterInfoType(stream, &MeteringReceiptReqType->MeterInfo, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeterInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 390:
            // Grammar: ID=390; read/write bits=1; START (MeterInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    // decode: element
                    error = decode_iso2_MeterInfoType(stream, &MeteringReceiptReqType->MeterInfo, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeterInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryReq; type={urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: MaxEntriesSAScheduleTuple, unsignedShort (0, 1); RequestedEnergyTransferMode, EnergyTransferModeType (1, 1); AC_EVChargeParameter, AC_EVChargeParameterType (0, 1); DC_EVChargeParameter, DC_EVChargeParameterType (0, 1); EVChargeParameter, EVChargeParameterType (0, 1);
static int decode_iso2_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, struct iso2_ChargeParameterDiscoveryReqType* ChargeParameterDiscoveryReqType, char* xmlOut) {
    int grammar_id = 391;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ChargeParameterDiscoveryReqType(ChargeParameterDiscoveryReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 391:
            // Grammar: ID=391; read/write bits=2; START (MaxEntriesSAScheduleTuple), START (RequestedEnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MaxEntriesSAScheduleTuple, unsignedShort (unsignedInt)); next=392

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MaxEntriesSAScheduleTuple");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MaxEntriesSAScheduleTuple");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ChargeParameterDiscoveryReqType->MaxEntriesSAScheduleTuple);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ChargeParameterDiscoveryReqType->MaxEntriesSAScheduleTuple);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        ChargeParameterDiscoveryReqType->MaxEntriesSAScheduleTuple_isUsed = 1u;
                        grammar_id = 392;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MaxEntriesSAScheduleTuple>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (RequestedEnergyTransferMode, EnergyTransferModeType (string)); next=393

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                ChargeParameterDiscoveryReqType->RequestedEnergyTransferMode = (iso2_EnergyTransferModeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 393;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 392:
            // Grammar: ID=392; read/write bits=1; START (RequestedEnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RequestedEnergyTransferMode, EnergyTransferModeType (string)); next=393

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                ChargeParameterDiscoveryReqType->RequestedEnergyTransferMode = (iso2_EnergyTransferModeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EnergyTransferModeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 393;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RequestedEnergyTransferMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 393:
            // Grammar: ID=393; read/write bits=2; START (AC_EVChargeParameter), START (DC_EVChargeParameter), START (EVChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVChargeParameter, AC_EVChargeParameterType (EVChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter");
                    // decode: element
                    error = decode_iso2_AC_EVChargeParameterType(stream, &ChargeParameterDiscoveryReqType->AC_EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryReqType->AC_EVChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVChargeParameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVChargeParameter, DC_EVChargeParameterType (EVChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter");
                    // decode: element
                    error = decode_iso2_DC_EVChargeParameterType(stream, &ChargeParameterDiscoveryReqType->DC_EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryReqType->DC_EVChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVChargeParameter>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVChargeParameter, EVChargeParameterType (EVChargeParameterType)); next=3
                    // decode: element
                    error = decode_iso2_EVChargeParameterType(stream, &ChargeParameterDiscoveryReqType->EVChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryReqType->EVChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}SessionSetupRes; type={urn:iso:15118:2:2013:MsgBody}SessionSetupResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); EVSEID, evseIDType (1, 1); EVSETimeStamp, long (0, 1);
static int decode_iso2_SessionSetupResType(exi_bitstream_t* stream, struct iso2_SessionSetupResType* SessionSetupResType, char* xmlOut) {
    int grammar_id = 394;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SessionSetupResType(SessionSetupResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 394:
            // Grammar: ID=394; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=395

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                SessionSetupResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 395;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 395:
            // Grammar: ID=395; read/write bits=1; START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=396

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionSetupResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (SessionSetupResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionSetupResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionSetupResType->EVSEID.charactersLen, SessionSetupResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < SessionSetupResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionSetupResType->EVSEID.characters[i]))
                                        {
                                            SessionSetupResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionSetupResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 396;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 396:
            // Grammar: ID=396; read/write bits=2; START (EVSETimeStamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSETimeStamp, long (integer)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp");
                    // decode: long int
                    error = decode_exi_type_integer64(stream, &SessionSetupResType->EVSETimeStamp);
                    if (error == 0)
                    {
                        char append[21]; // max length: 19 digits + 1 sign + 1 zero terminator
                        sprintf(append, "%" PRIi64, SessionSetupResType->EVSETimeStamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        SessionSetupResType->EVSETimeStamp_isUsed = 1u;
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSETimeStamp>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}SessionSetupReq; type={urn:iso:15118:2:2013:MsgBody}SessionSetupReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVCCID, evccIDType (1, 1);
static int decode_iso2_SessionSetupReqType(exi_bitstream_t* stream, struct iso2_SessionSetupReqType* SessionSetupReqType, char* xmlOut) {
    int grammar_id = 397;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SessionSetupReqType(SessionSetupReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 397:
            // Grammar: ID=397; read/write bits=1; START (EVCCID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVCCID, evccIDType (hexBinary)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVCCID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVCCID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &SessionSetupReqType->EVCCID.bytesLen, &SessionSetupReqType->EVCCID.bytes[0], iso2_evccIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &SessionSetupReqType->EVCCID.bytes[0];
                        uint16_t len = SessionSetupReqType->EVCCID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 3;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVCCID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}SessionStopRes; type={urn:iso:15118:2:2013:MsgBody}SessionStopResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1);
static int decode_iso2_SessionStopResType(exi_bitstream_t* stream, struct iso2_SessionStopResType* SessionStopResType, char* xmlOut) {
    int grammar_id = 398;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_SessionStopResType(SessionStopResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 398:
            // Grammar: ID=398; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                SessionStopResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PowerDeliveryRes; type={urn:iso:15118:2:2013:MsgBody}PowerDeliveryResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); AC_EVSEStatus, AC_EVSEStatusType (0, 1); DC_EVSEStatus, DC_EVSEStatusType (0, 1); EVSEStatus, EVSEStatusType (0, 1);
static int decode_iso2_PowerDeliveryResType(exi_bitstream_t* stream, struct iso2_PowerDeliveryResType* PowerDeliveryResType, char* xmlOut) {
    int grammar_id = 399;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PowerDeliveryResType(PowerDeliveryResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 399:
            // Grammar: ID=399; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=400

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                PowerDeliveryResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 400;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 400:
            // Grammar: ID=400; read/write bits=2; START (AC_EVSEStatus), START (DC_EVSEStatus), START (EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &PowerDeliveryResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryResType->AC_EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &PowerDeliveryResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryResType->DC_EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=3
                    // decode: element
                    error = decode_iso2_EVSEStatusType(stream, &PowerDeliveryResType->EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        PowerDeliveryResType->EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CurrentDemandRes; type={urn:iso:15118:2:2013:MsgBody}CurrentDemandResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); DC_EVSEStatus, DC_EVSEStatusType (1, 1); EVSEPresentVoltage, PhysicalValueType (1, 1); EVSEPresentCurrent, PhysicalValueType (1, 1); EVSECurrentLimitAchieved, boolean (1, 1); EVSEVoltageLimitAchieved, boolean (1, 1); EVSEPowerLimitAchieved, boolean (1, 1); EVSEMaximumVoltageLimit, PhysicalValueType (0, 1); EVSEMaximumCurrentLimit, PhysicalValueType (0, 1); EVSEMaximumPowerLimit, PhysicalValueType (0, 1); EVSEID, evseIDType (1, 1); SAScheduleTupleID, SAIDType (1, 1); MeterInfo, MeterInfoType (0, 1); ReceiptRequired, boolean (0, 1);
static int decode_iso2_CurrentDemandResType(exi_bitstream_t* stream, struct iso2_CurrentDemandResType* CurrentDemandResType, char* xmlOut) {
    int grammar_id = 401;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CurrentDemandResType(CurrentDemandResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 401:
            // Grammar: ID=401; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=402

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 402;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 402:
            // Grammar: ID=402; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=403

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &CurrentDemandResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 403;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 403:
            // Grammar: ID=403; read/write bits=1; START (EVSEPresentVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPresentVoltage, PhysicalValueType (PhysicalValueType)); next=404

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEPresentVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 404;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 404:
            // Grammar: ID=404; read/write bits=1; START (EVSEPresentCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPresentCurrent, PhysicalValueType (PhysicalValueType)); next=405

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEPresentCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEPresentCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEPresentCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 405;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEPresentCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 405:
            // Grammar: ID=405; read/write bits=1; START (EVSECurrentLimitAchieved)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSECurrentLimitAchieved, boolean (boolean)); next=406

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSECurrentLimitAchieved");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSECurrentLimitAchieved");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->EVSECurrentLimitAchieved = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 406;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSECurrentLimitAchieved>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 406:
            // Grammar: ID=406; read/write bits=1; START (EVSEVoltageLimitAchieved)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEVoltageLimitAchieved, boolean (boolean)); next=407

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEVoltageLimitAchieved");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEVoltageLimitAchieved");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->EVSEVoltageLimitAchieved = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 407;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEVoltageLimitAchieved>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 407:
            // Grammar: ID=407; read/write bits=1; START (EVSEPowerLimitAchieved)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPowerLimitAchieved, boolean (boolean)); next=408

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEPowerLimitAchieved");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEPowerLimitAchieved");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->EVSEPowerLimitAchieved = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 408;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEPowerLimitAchieved>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 408:
            // Grammar: ID=408; read/write bits=3; START (EVSEMaximumVoltageLimit), START (EVSEMaximumCurrentLimit), START (EVSEMaximumPowerLimit), START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=409

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumVoltageLimit_isUsed = 1u;
                        grammar_id = 409;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumVoltageLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVSEMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=410

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumCurrentLimit_isUsed = 1u;
                        grammar_id = 410;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVSEMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=411

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 411;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=412

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &CurrentDemandResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (CurrentDemandResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    CurrentDemandResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, CurrentDemandResType->EVSEID.charactersLen, CurrentDemandResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < CurrentDemandResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(CurrentDemandResType->EVSEID.characters[i]))
                                        {
                                            CurrentDemandResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, CurrentDemandResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 412;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 409:
            // Grammar: ID=409; read/write bits=2; START (EVSEMaximumCurrentLimit), START (EVSEMaximumPowerLimit), START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=410

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumCurrentLimit_isUsed = 1u;
                        grammar_id = 410;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumCurrentLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVSEMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=411

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 411;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=412

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &CurrentDemandResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (CurrentDemandResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    CurrentDemandResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, CurrentDemandResType->EVSEID.charactersLen, CurrentDemandResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < CurrentDemandResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(CurrentDemandResType->EVSEID.characters[i]))
                                        {
                                            CurrentDemandResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, CurrentDemandResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 412;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 410:
            // Grammar: ID=410; read/write bits=2; START (EVSEMaximumPowerLimit), START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=411

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandResType->EVSEMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->EVSEMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 411;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaximumPowerLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=412

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &CurrentDemandResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (CurrentDemandResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    CurrentDemandResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, CurrentDemandResType->EVSEID.charactersLen, CurrentDemandResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < CurrentDemandResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(CurrentDemandResType->EVSEID.characters[i]))
                                        {
                                            CurrentDemandResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, CurrentDemandResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 412;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 411:
            // Grammar: ID=411; read/write bits=1; START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=412

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &CurrentDemandResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (CurrentDemandResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    CurrentDemandResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, CurrentDemandResType->EVSEID.charactersLen, CurrentDemandResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < CurrentDemandResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(CurrentDemandResType->EVSEID.characters[i]))
                                        {
                                            CurrentDemandResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, CurrentDemandResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 412;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 412:
            // Grammar: ID=412; read/write bits=1; START (SAScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTupleID, SAIDType (unsignedByte)); next=413

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                CurrentDemandResType->SAScheduleTupleID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", CurrentDemandResType->SAScheduleTupleID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 413;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 413:
            // Grammar: ID=413; read/write bits=2; START (MeterInfo), START (ReceiptRequired), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=414

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    // decode: element
                    error = decode_iso2_MeterInfoType(stream, &CurrentDemandResType->MeterInfo, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandResType->MeterInfo_isUsed = 1u;
                        grammar_id = 414;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeterInfo>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ReceiptRequired, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->ReceiptRequired = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandResType->ReceiptRequired_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ReceiptRequired>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 414:
            // Grammar: ID=414; read/write bits=2; START (ReceiptRequired), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ReceiptRequired, boolean (boolean)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandResType->ReceiptRequired = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandResType->ReceiptRequired_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ReceiptRequired>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryRes; type={urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); EVSEProcessing, EVSEProcessingType (1, 1); SAScheduleList, SAScheduleListType (0, 1); SASchedules, SASchedulesType (0, 1); AC_EVSEChargeParameter, AC_EVSEChargeParameterType (0, 1); DC_EVSEChargeParameter, DC_EVSEChargeParameterType (0, 1); EVSEChargeParameter, EVSEChargeParameterType (0, 1);
static int decode_iso2_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, struct iso2_ChargeParameterDiscoveryResType* ChargeParameterDiscoveryResType, char* xmlOut) {
    int grammar_id = 415;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ChargeParameterDiscoveryResType(ChargeParameterDiscoveryResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 415:
            // Grammar: ID=415; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=416

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                ChargeParameterDiscoveryResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 416;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 416:
            // Grammar: ID=416; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, EVSEProcessingType (string)); next=417

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ChargeParameterDiscoveryResType->EVSEProcessing = (iso2_EVSEProcessingType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSEProcessingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 417;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 417:
            // Grammar: ID=417; read/write bits=3; START (SAScheduleList), START (SASchedules), START (AC_EVSEChargeParameter), START (DC_EVSEChargeParameter), START (EVSEChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleList, SAScheduleListType (SASchedulesType)); next=418

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleList");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleList");
                    // decode: element
                    error = decode_iso2_SAScheduleListType(stream, &ChargeParameterDiscoveryResType->SAScheduleList, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->SAScheduleList_isUsed = 1u;
                        grammar_id = 418;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}SAScheduleList>");
                    }
                    break;
                case 1:
                    {
                    // Abstract element or type: SASchedules, SASchedulesType (SASchedulesType)
                    // decode: element
                    error = decode_iso2_SASchedulesType(stream, &ChargeParameterDiscoveryResType->SASchedules, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->SASchedules_isUsed = 1u;
                        grammar_id = 418;
                    }

                    }
                    break;
                case 2:
                    {
                    // Event: START (AC_EVSEChargeParameter, AC_EVSEChargeParameterType (EVSEChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter");
                    // decode: element
                    error = decode_iso2_AC_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->AC_EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->AC_EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (DC_EVSEChargeParameter, DC_EVSEChargeParameterType (EVSEChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter");
                    // decode: element
                    error = decode_iso2_DC_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->DC_EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->DC_EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter>");
                    }
                    break;
                case 4:
                    {
                    // Abstract element or type: EVSEChargeParameter, EVSEChargeParameterType (EVSEChargeParameterType)
                    // decode: element
                    error = decode_iso2_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 418:
            // Grammar: ID=418; read/write bits=2; START (AC_EVSEChargeParameter), START (DC_EVSEChargeParameter), START (EVSEChargeParameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEChargeParameter, AC_EVSEChargeParameterType (EVSEChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter");
                    // decode: element
                    error = decode_iso2_AC_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->AC_EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->AC_EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEChargeParameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVSEChargeParameter, DC_EVSEChargeParameterType (EVSEChargeParameterType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter");
                    // decode: element
                    error = decode_iso2_DC_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->DC_EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->DC_EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEChargeParameter>");
                    }
                    break;
                case 2:
                    {
                    // Abstract element or type: EVSEChargeParameter, EVSEChargeParameterType (EVSEChargeParameterType)
                    // decode: element
                    error = decode_iso2_EVSEChargeParameterType(stream, &ChargeParameterDiscoveryResType->EVSEChargeParameter, xmlOut);
                    if (error == 0)
                    {
                        ChargeParameterDiscoveryResType->EVSEChargeParameter_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargingStatusRes; type={urn:iso:15118:2:2013:MsgBody}ChargingStatusResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); EVSEID, evseIDType (1, 1); SAScheduleTupleID, SAIDType (1, 1); EVSEMaxCurrent, PhysicalValueType (0, 1); MeterInfo, MeterInfoType (0, 1); ReceiptRequired, boolean (0, 1); AC_EVSEStatus, AC_EVSEStatusType (1, 1);
static int decode_iso2_ChargingStatusResType(exi_bitstream_t* stream, struct iso2_ChargingStatusResType* ChargingStatusResType, char* xmlOut) {
    int grammar_id = 419;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ChargingStatusResType(ChargingStatusResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 419:
            // Grammar: ID=419; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=420

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                ChargingStatusResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 420;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 420:
            // Grammar: ID=420; read/write bits=1; START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEID, evseIDType (string)); next=421

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ChargingStatusResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (ChargingStatusResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ChargingStatusResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ChargingStatusResType->EVSEID.charactersLen, ChargingStatusResType->EVSEID.characters, iso2_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ChargingStatusResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ChargingStatusResType->EVSEID.characters[i]))
                                        {
                                            ChargingStatusResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ChargingStatusResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 421;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 421:
            // Grammar: ID=421; read/write bits=1; START (SAScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SAScheduleTupleID, SAIDType (unsignedByte)); next=422

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = 1
                                ChargingStatusResType->SAScheduleTupleID = (uint8_t)(value + 1);
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", ChargingStatusResType->SAScheduleTupleID);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 422;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SAScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 422:
            // Grammar: ID=422; read/write bits=3; START (EVSEMaxCurrent), START (MeterInfo), START (ReceiptRequired), START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEMaxCurrent, PhysicalValueType (PhysicalValueType)); next=423

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEMaxCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEMaxCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &ChargingStatusResType->EVSEMaxCurrent, xmlOut);
                    if (error == 0)
                    {
                        ChargingStatusResType->EVSEMaxCurrent_isUsed = 1u;
                        grammar_id = 423;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEMaxCurrent>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=424

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    // decode: element
                    error = decode_iso2_MeterInfoType(stream, &ChargingStatusResType->MeterInfo, xmlOut);
                    if (error == 0)
                    {
                        ChargingStatusResType->MeterInfo_isUsed = 1u;
                        grammar_id = 424;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeterInfo>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (ReceiptRequired, boolean (boolean)); next=425

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ChargingStatusResType->ReceiptRequired = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ChargingStatusResType->ReceiptRequired_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 425;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ReceiptRequired>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &ChargingStatusResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 423:
            // Grammar: ID=423; read/write bits=2; START (MeterInfo), START (ReceiptRequired), START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=424

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}MeterInfo");
                    // decode: element
                    error = decode_iso2_MeterInfoType(stream, &ChargingStatusResType->MeterInfo, xmlOut);
                    if (error == 0)
                    {
                        ChargingStatusResType->MeterInfo_isUsed = 1u;
                        grammar_id = 424;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeterInfo>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ReceiptRequired, boolean (boolean)); next=425

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ChargingStatusResType->ReceiptRequired = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ChargingStatusResType->ReceiptRequired_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 425;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ReceiptRequired>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &ChargingStatusResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 424:
            // Grammar: ID=424; read/write bits=2; START (ReceiptRequired), START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ReceiptRequired, boolean (boolean)); next=425

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ReceiptRequired");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ChargingStatusResType->ReceiptRequired = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ChargingStatusResType->ReceiptRequired_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 425;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ReceiptRequired>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &ChargingStatusResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 425:
            // Grammar: ID=425; read/write bits=1; START (AC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &ChargingStatusResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryReq; type={urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ServiceScope, serviceScopeType (0, 1); ServiceCategory, serviceCategoryType (0, 1);
static int decode_iso2_ServiceDiscoveryReqType(exi_bitstream_t* stream, struct iso2_ServiceDiscoveryReqType* ServiceDiscoveryReqType, char* xmlOut) {
    int grammar_id = 426;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceDiscoveryReqType(ServiceDiscoveryReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 426:
            // Grammar: ID=426; read/write bits=2; START (ServiceScope), START (ServiceCategory), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceScope, serviceScopeType (string)); next=427

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceScope");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceScope");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ServiceDiscoveryReqType->ServiceScope.charactersLen);
                            if (error == 0)
                            {
                                if (ServiceDiscoveryReqType->ServiceScope.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ServiceDiscoveryReqType->ServiceScope.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ServiceDiscoveryReqType->ServiceScope.charactersLen, ServiceDiscoveryReqType->ServiceScope.characters, iso2_ServiceScope_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < ServiceDiscoveryReqType->ServiceScope.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ServiceDiscoveryReqType->ServiceScope.characters[i]))
                                        {
                                            ServiceDiscoveryReqType->ServiceScope.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ServiceDiscoveryReqType->ServiceScope.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ServiceDiscoveryReqType->ServiceScope_isUsed = 1u;
                                grammar_id = 427;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceScope>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ServiceDiscoveryReqType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                                ServiceDiscoveryReqType->ServiceCategory_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceCategory>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 427:
            // Grammar: ID=427; read/write bits=2; START (ServiceCategory), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceCategory, serviceCategoryType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceCategory");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceCategory");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ServiceDiscoveryReqType->ServiceCategory = (iso2_serviceCategoryType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_serviceCategoryType_reverse(value));
                                ServiceDiscoveryReqType->ServiceCategory_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceCategory>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PaymentDetailsReq; type={urn:iso:15118:2:2013:MsgBody}PaymentDetailsReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: eMAID, eMAIDType (1, 1); ContractSignatureCertChain, CertificateChainType (1, 1);
static int decode_iso2_PaymentDetailsReqType(exi_bitstream_t* stream, struct iso2_PaymentDetailsReqType* PaymentDetailsReqType, char* xmlOut) {
    int grammar_id = 428;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PaymentDetailsReqType(PaymentDetailsReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 428:
            // Grammar: ID=428; read/write bits=1; START (eMAID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (eMAID, eMAIDType (string)); next=429

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}eMAID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &PaymentDetailsReqType->eMAID.charactersLen);
                            if (error == 0)
                            {
                                if (PaymentDetailsReqType->eMAID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    PaymentDetailsReqType->eMAID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, PaymentDetailsReqType->eMAID.charactersLen, PaymentDetailsReqType->eMAID.characters, iso2_eMAID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    for(int i = 0; i < PaymentDetailsReqType->eMAID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(PaymentDetailsReqType->eMAID.characters[i]))
                                        {
                                            PaymentDetailsReqType->eMAID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, PaymentDetailsReqType->eMAID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 429;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}eMAID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 429:
            // Grammar: ID=429; read/write bits=1; START (ContractSignatureCertChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractSignatureCertChain, CertificateChainType (CertificateChainType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain");
                    // decode: element
                    error = decode_iso2_CertificateChainType(stream, &PaymentDetailsReqType->ContractSignatureCertChain, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ContractSignatureCertChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionReq; type={urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: SelectedPaymentOption, paymentOptionType (1, 1); SelectedServiceList, SelectedServiceListType (1, 1);
static int decode_iso2_PaymentServiceSelectionReqType(exi_bitstream_t* stream, struct iso2_PaymentServiceSelectionReqType* PaymentServiceSelectionReqType, char* xmlOut) {
    int grammar_id = 430;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PaymentServiceSelectionReqType(PaymentServiceSelectionReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 430:
            // Grammar: ID=430; read/write bits=1; START (SelectedPaymentOption)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedPaymentOption, paymentOptionType (string)); next=431

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SelectedPaymentOption");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SelectedPaymentOption");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                PaymentServiceSelectionReqType->SelectedPaymentOption = (iso2_paymentOptionType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_paymentOptionType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 431;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SelectedPaymentOption>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 431:
            // Grammar: ID=431; read/write bits=1; START (SelectedServiceList)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedServiceList, SelectedServiceListType (SelectedServiceListType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}SelectedServiceList");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}SelectedServiceList");
                    // decode: element
                    error = decode_iso2_SelectedServiceListType(stream, &PaymentServiceSelectionReqType->SelectedServiceList, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SelectedServiceList>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceDetailRes; type={urn:iso:15118:2:2013:MsgBody}ServiceDetailResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); ServiceID, serviceIDType (1, 1); ServiceParameterList, ServiceParameterListType (0, 1);
static int decode_iso2_ServiceDetailResType(exi_bitstream_t* stream, struct iso2_ServiceDetailResType* ServiceDetailResType, char* xmlOut) {
    int grammar_id = 432;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceDetailResType(ServiceDetailResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 432:
            // Grammar: ID=432; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=433

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                ServiceDetailResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 433;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 433:
            // Grammar: ID=433; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=434

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceID");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceDetailResType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        sprintf(append, "%u", ServiceDetailResType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 434;
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 434:
            // Grammar: ID=434; read/write bits=2; START (ServiceParameterList), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceParameterList, ServiceParameterListType (ServiceParameterListType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceParameterList");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceParameterList");
                    // decode: element
                    error = decode_iso2_ServiceParameterListType(stream, &ServiceDetailResType->ServiceParameterList, xmlOut);
                    if (error == 0)
                    {
                        ServiceDetailResType->ServiceParameterList_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceParameterList>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PreChargeRes; type={urn:iso:15118:2:2013:MsgBody}PreChargeResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); DC_EVSEStatus, DC_EVSEStatusType (1, 1); EVSEPresentVoltage, PhysicalValueType (1, 1);
static int decode_iso2_PreChargeResType(exi_bitstream_t* stream, struct iso2_PreChargeResType* PreChargeResType, char* xmlOut) {
    int grammar_id = 435;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PreChargeResType(PreChargeResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 435:
            // Grammar: ID=435; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=436

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                PreChargeResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 436;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 436:
            // Grammar: ID=436; read/write bits=1; START (DC_EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=437

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &PreChargeResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 437;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVSEStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 437:
            // Grammar: ID=437; read/write bits=1; START (EVSEPresentVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEPresentVoltage, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &PreChargeResType->EVSEPresentVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEPresentVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryRes; type={urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); PaymentOptionList, PaymentOptionListType (1, 1); ChargeService, ChargeServiceType (1, 1); ServiceList, ServiceListType (0, 1);
static int decode_iso2_ServiceDiscoveryResType(exi_bitstream_t* stream, struct iso2_ServiceDiscoveryResType* ServiceDiscoveryResType, char* xmlOut) {
    int grammar_id = 438;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_ServiceDiscoveryResType(ServiceDiscoveryResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 438:
            // Grammar: ID=438; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=439

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                ServiceDiscoveryResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 439;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 439:
            // Grammar: ID=439; read/write bits=1; START (PaymentOptionList)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (PaymentOptionList, PaymentOptionListType (PaymentOptionListType)); next=440

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}PaymentOptionList");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}PaymentOptionList");
                    // decode: element
                    error = decode_iso2_PaymentOptionListType(stream, &ServiceDiscoveryResType->PaymentOptionList, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 440;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PaymentOptionList>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 440:
            // Grammar: ID=440; read/write bits=1; START (ChargeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargeService, ChargeServiceType (ServiceType)); next=441

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargeService");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargeService");
                    // decode: element
                    error = decode_iso2_ChargeServiceType(stream, &ServiceDiscoveryResType->ChargeService, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 441;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 441:
            // Grammar: ID=441; read/write bits=2; START (ServiceList), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceList, ServiceListType (ServiceListType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ServiceList");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ServiceList");
                    // decode: element
                    error = decode_iso2_ServiceListType(stream, &ServiceDiscoveryResType->ServiceList, xmlOut);
                    if (error == 0)
                    {
                        ServiceDiscoveryResType->ServiceList_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceList>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CableCheckReq; type={urn:iso:15118:2:2013:MsgBody}CableCheckReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVStatus, DC_EVStatusType (1, 1);
static int decode_iso2_CableCheckReqType(exi_bitstream_t* stream, struct iso2_CableCheckReqType* CableCheckReqType, char* xmlOut) {
    int grammar_id = 442;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CableCheckReqType(CableCheckReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 442:
            // Grammar: ID=442; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &CableCheckReqType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}MeteringReceiptRes; type={urn:iso:15118:2:2013:MsgBody}MeteringReceiptResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); AC_EVSEStatus, AC_EVSEStatusType (0, 1); DC_EVSEStatus, DC_EVSEStatusType (0, 1); EVSEStatus, EVSEStatusType (0, 1);
static int decode_iso2_MeteringReceiptResType(exi_bitstream_t* stream, struct iso2_MeteringReceiptResType* MeteringReceiptResType, char* xmlOut) {
    int grammar_id = 443;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_MeteringReceiptResType(MeteringReceiptResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 443:
            // Grammar: ID=443; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=444

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                MeteringReceiptResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 444;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 444:
            // Grammar: ID=444; read/write bits=2; START (AC_EVSEStatus), START (DC_EVSEStatus), START (EVSEStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (AC_EVSEStatus, AC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_AC_EVSEStatusType(stream, &MeteringReceiptResType->AC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        MeteringReceiptResType->AC_EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}AC_EVSEStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DC_EVSEStatus, DC_EVSEStatusType (EVSEStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus");
                    // decode: element
                    error = decode_iso2_DC_EVSEStatusType(stream, &MeteringReceiptResType->DC_EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        MeteringReceiptResType->DC_EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDataTypes}DC_EVSEStatus>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=3
                    // decode: element
                    error = decode_iso2_EVSEStatusType(stream, &MeteringReceiptResType->EVSEStatus, xmlOut);
                    if (error == 0)
                    {
                        MeteringReceiptResType->EVSEStatus_isUsed = 1u;
                        grammar_id = 3;
                    }

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}AuthorizationRes; type={urn:iso:15118:2:2013:MsgBody}AuthorizationResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1); EVSEProcessing, EVSEProcessingType (1, 1);
static int decode_iso2_AuthorizationResType(exi_bitstream_t* stream, struct iso2_AuthorizationResType* AuthorizationResType, char* xmlOut) {
    int grammar_id = 445;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_AuthorizationResType(AuthorizationResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 445:
            // Grammar: ID=445; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=446

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                AuthorizationResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 446;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 446:
            // Grammar: ID=446; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, EVSEProcessingType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                AuthorizationResType->EVSEProcessing = (iso2_EVSEProcessingType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_EVSEProcessingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}CurrentDemandReq; type={urn:iso:15118:2:2013:MsgBody}CurrentDemandReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVStatus, DC_EVStatusType (1, 1); EVTargetCurrent, PhysicalValueType (1, 1); EVMaximumVoltageLimit, PhysicalValueType (0, 1); EVMaximumCurrentLimit, PhysicalValueType (0, 1); EVMaximumPowerLimit, PhysicalValueType (0, 1); BulkChargingComplete, boolean (0, 1); ChargingComplete, boolean (1, 1); RemainingTimeToFullSoC, PhysicalValueType (0, 1); RemainingTimeToBulkSoC, PhysicalValueType (0, 1); EVTargetVoltage, PhysicalValueType (1, 1);
static int decode_iso2_CurrentDemandReqType(exi_bitstream_t* stream, struct iso2_CurrentDemandReqType* CurrentDemandReqType, char* xmlOut) {
    int grammar_id = 447;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_CurrentDemandReqType(CurrentDemandReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 447:
            // Grammar: ID=447; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=448

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &CurrentDemandReqType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 448;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 448:
            // Grammar: ID=448; read/write bits=1; START (EVTargetCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetCurrent, PhysicalValueType (PhysicalValueType)); next=449

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVTargetCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 449;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 449:
            // Grammar: ID=449; read/write bits=3; START (EVMaximumVoltageLimit), START (EVMaximumCurrentLimit), START (EVMaximumPowerLimit), START (BulkChargingComplete), START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumVoltageLimit, PhysicalValueType (PhysicalValueType)); next=450

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumVoltageLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumVoltageLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumVoltageLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumVoltageLimit_isUsed = 1u;
                        grammar_id = 450;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumVoltageLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=451

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumCurrentLimit_isUsed = 1u;
                        grammar_id = 451;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=452

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 452;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (BulkChargingComplete, boolean (boolean)); next=453

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->BulkChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandReqType->BulkChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 453;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=454

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 454;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 450:
            // Grammar: ID=450; read/write bits=3; START (EVMaximumCurrentLimit), START (EVMaximumPowerLimit), START (BulkChargingComplete), START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumCurrentLimit, PhysicalValueType (PhysicalValueType)); next=451

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumCurrentLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumCurrentLimit_isUsed = 1u;
                        grammar_id = 451;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumCurrentLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=452

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 452;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (BulkChargingComplete, boolean (boolean)); next=453

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->BulkChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandReqType->BulkChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 453;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=454

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 454;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 451:
            // Grammar: ID=451; read/write bits=2; START (EVMaximumPowerLimit), START (BulkChargingComplete), START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumPowerLimit, PhysicalValueType (PhysicalValueType)); next=452

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVMaximumPowerLimit, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->EVMaximumPowerLimit_isUsed = 1u;
                        grammar_id = 452;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVMaximumPowerLimit>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (BulkChargingComplete, boolean (boolean)); next=453

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->BulkChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandReqType->BulkChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 453;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=454

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 454;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 452:
            // Grammar: ID=452; read/write bits=2; START (BulkChargingComplete), START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (BulkChargingComplete, boolean (boolean)); next=453

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->BulkChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                CurrentDemandReqType->BulkChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 453;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}BulkChargingComplete>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=454

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 454;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 453:
            // Grammar: ID=453; read/write bits=1; START (ChargingComplete)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingComplete, boolean (boolean)); next=454

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ChargingComplete");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                CurrentDemandReqType->ChargingComplete = value;
                                    strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 454;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingComplete>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 454:
            // Grammar: ID=454; read/write bits=2; START (RemainingTimeToFullSoC), START (RemainingTimeToBulkSoC), START (EVTargetVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RemainingTimeToFullSoC, PhysicalValueType (PhysicalValueType)); next=455

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToFullSoC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToFullSoC");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->RemainingTimeToFullSoC, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->RemainingTimeToFullSoC_isUsed = 1u;
                        grammar_id = 455;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RemainingTimeToFullSoC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (RemainingTimeToBulkSoC, PhysicalValueType (PhysicalValueType)); next=456

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->RemainingTimeToBulkSoC, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->RemainingTimeToBulkSoC_isUsed = 1u;
                        grammar_id = 456;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVTargetVoltage, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVTargetVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 455:
            // Grammar: ID=455; read/write bits=2; START (RemainingTimeToBulkSoC), START (EVTargetVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (RemainingTimeToBulkSoC, PhysicalValueType (PhysicalValueType)); next=456

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->RemainingTimeToBulkSoC, xmlOut);
                    if (error == 0)
                    {
                        CurrentDemandReqType->RemainingTimeToBulkSoC_isUsed = 1u;
                        grammar_id = 456;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}RemainingTimeToBulkSoC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVTargetVoltage, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVTargetVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 456:
            // Grammar: ID=456; read/write bits=1; START (EVTargetVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetVoltage, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &CurrentDemandReqType->EVTargetVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionRes; type={urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionResType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: ResponseCode, responseCodeType (1, 1);
static int decode_iso2_PaymentServiceSelectionResType(exi_bitstream_t* stream, struct iso2_PaymentServiceSelectionResType* PaymentServiceSelectionResType, char* xmlOut) {
    int grammar_id = 457;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PaymentServiceSelectionResType(PaymentServiceSelectionResType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 457:
            // Grammar: ID=457; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 5, &value);
                            if (error == 0)
                            {
                                PaymentServiceSelectionResType->ResponseCode = (iso2_responseCodeType)value;
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso2_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 3;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}ChargingStatusReq; type={urn:iso:15118:2:2013:MsgBody}ChargingStatusReqType; base type=BodyBaseType; content type=empty;
//          abstract=False; final=False; derivation=extension;
static int decode_iso2_ChargingStatusReqType(exi_bitstream_t* stream, struct iso2_ChargingStatusReqType* ChargingStatusReqType, char* xmlOut) {
    // Element has no particles, so the function just decodes END Element
    (void)ChargingStatusReqType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}WeldingDetectionReq; type={urn:iso:15118:2:2013:MsgBody}WeldingDetectionReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVStatus, DC_EVStatusType (1, 1);
static int decode_iso2_WeldingDetectionReqType(exi_bitstream_t* stream, struct iso2_WeldingDetectionReqType* WeldingDetectionReqType, char* xmlOut) {
    int grammar_id = 458;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_WeldingDetectionReqType(WeldingDetectionReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 458:
            // Grammar: ID=458; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &WeldingDetectionReqType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgBody}PreChargeReq; type={urn:iso:15118:2:2013:MsgBody}PreChargeReqType; base type=BodyBaseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DC_EVStatus, DC_EVStatusType (1, 1); EVTargetVoltage, PhysicalValueType (1, 1); EVTargetCurrent, PhysicalValueType (1, 1);
static int decode_iso2_PreChargeReqType(exi_bitstream_t* stream, struct iso2_PreChargeReqType* PreChargeReqType, char* xmlOut) {
    int grammar_id = 459;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_PreChargeReqType(PreChargeReqType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 459:
            // Grammar: ID=459; read/write bits=1; START (DC_EVStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (DC_EVStatus, DC_EVStatusType (EVStatusType)); next=460

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}DC_EVStatus");
                    // decode: element
                    error = decode_iso2_DC_EVStatusType(stream, &PreChargeReqType->DC_EVStatus, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}DC_EVStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 460:
            // Grammar: ID=460; read/write bits=1; START (EVTargetVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetVoltage, PhysicalValueType (PhysicalValueType)); next=461

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &PreChargeReqType->EVTargetVoltage, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 461;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetVoltage>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 461:
            // Grammar: ID=461; read/write bits=1; START (EVTargetCurrent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetCurrent, PhysicalValueType (PhysicalValueType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent");
                    // decode: element
                    error = decode_iso2_PhysicalValueType(stream, &PreChargeReqType->EVTargetCurrent, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}EVTargetCurrent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDef}Body; type={urn:iso:15118:2:2013:MsgBody}BodyType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: AuthorizationReq, AuthorizationReqType (0, 1); AuthorizationRes, AuthorizationResType (0, 1); BodyElement, BodyBaseType (0, 1); CableCheckReq, CableCheckReqType (0, 1); CableCheckRes, CableCheckResType (0, 1); CertificateInstallationReq, CertificateInstallationReqType (0, 1); CertificateInstallationRes, CertificateInstallationResType (0, 1); CertificateUpdateReq, CertificateUpdateReqType (0, 1); CertificateUpdateRes, CertificateUpdateResType (0, 1); ChargeParameterDiscoveryReq, ChargeParameterDiscoveryReqType (0, 1); ChargeParameterDiscoveryRes, ChargeParameterDiscoveryResType (0, 1); ChargingStatusReq, ChargingStatusReqType (0, 1); ChargingStatusRes, ChargingStatusResType (0, 1); CurrentDemandReq, CurrentDemandReqType (0, 1); CurrentDemandRes, CurrentDemandResType (0, 1); MeteringReceiptReq, MeteringReceiptReqType (0, 1); MeteringReceiptRes, MeteringReceiptResType (0, 1); PaymentDetailsReq, PaymentDetailsReqType (0, 1); PaymentDetailsRes, PaymentDetailsResType (0, 1); PaymentServiceSelectionReq, PaymentServiceSelectionReqType (0, 1); PaymentServiceSelectionRes, PaymentServiceSelectionResType (0, 1); PowerDeliveryReq, PowerDeliveryReqType (0, 1); PowerDeliveryRes, PowerDeliveryResType (0, 1); PreChargeReq, PreChargeReqType (0, 1); PreChargeRes, PreChargeResType (0, 1); ServiceDetailReq, ServiceDetailReqType (0, 1); ServiceDetailRes, ServiceDetailResType (0, 1); ServiceDiscoveryReq, ServiceDiscoveryReqType (0, 1); ServiceDiscoveryRes, ServiceDiscoveryResType (0, 1); SessionSetupReq, SessionSetupReqType (0, 1); SessionSetupRes, SessionSetupResType (0, 1); SessionStopReq, SessionStopReqType (0, 1); SessionStopRes, SessionStopResType (0, 1); WeldingDetectionReq, WeldingDetectionReqType (0, 1); WeldingDetectionRes, WeldingDetectionResType (0, 1);
static int decode_iso2_BodyType(exi_bitstream_t* stream, struct iso2_BodyType* BodyType, char* xmlOut) {
    int grammar_id = 462;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_BodyType(BodyType);

    while(!done)
    {
        switch(grammar_id)
        {
        case 462:
            // Grammar: ID=462; read bits=6; START (BodyMessage)
            error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: AuthorizationReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}AuthorizationReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_AuthorizationReqType(stream, &BodyType->AuthorizationReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->AuthorizationReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AuthorizationReq>");
                    }
                    break;
                case 1:
                    {
                    // Event: AuthorizationRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}AuthorizationRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_AuthorizationResType(stream, &BodyType->AuthorizationRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->AuthorizationRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}AuthorizationRes>");
                    }
                    break;
                case 2:
                    {
                    // Event: BodyElement
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}BodyElement");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_BodyBaseType(stream, &BodyType->BodyElement, xmlOut);
                    if (error == 0)
                    {
                        BodyType->BodyElement_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}BodyElement>");
                    }
                    break;
                case 3:
                    {
                    // Event: CableCheckReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CableCheckReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CableCheckReqType(stream, &BodyType->CableCheckReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CableCheckReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CableCheckReq>");
                    }
                    break;
                case 4:
                    {
                    // Event: CableCheckRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CableCheckRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CableCheckResType(stream, &BodyType->CableCheckRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CableCheckRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CableCheckRes>");
                    }
                    break;
                case 5:
                    {
                    // Event: CertificateInstallationReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CertificateInstallationReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CertificateInstallationReqType(stream, &BodyType->CertificateInstallationReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CertificateInstallationReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CertificateInstallationReq>");
                    }
                    break;
                case 6:
                    {
                    // Event: CertificateInstallationRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CertificateInstallationRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CertificateInstallationResType(stream, &BodyType->CertificateInstallationRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CertificateInstallationRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CertificateInstallationRes>");
                    }
                    break;
                case 7:
                    {
                    // Event: CertificateUpdateReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CertificateUpdateReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CertificateUpdateReqType(stream, &BodyType->CertificateUpdateReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CertificateUpdateReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CertificateUpdateReq>");
                    }
                    break;
                case 8:
                    {
                    // Event: CertificateUpdateRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CertificateUpdateRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CertificateUpdateResType(stream, &BodyType->CertificateUpdateRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CertificateUpdateRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CertificateUpdateRes>");
                    }
                    break;
                case 9:
                    {
                    // Event: ChargeParameterDiscoveryReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ChargeParameterDiscoveryReqType(stream, &BodyType->ChargeParameterDiscoveryReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ChargeParameterDiscoveryReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryReq>");
                    }
                    break;
                case 10:
                    {
                    // Event: ChargeParameterDiscoveryRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ChargeParameterDiscoveryResType(stream, &BodyType->ChargeParameterDiscoveryRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ChargeParameterDiscoveryRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargeParameterDiscoveryRes>");
                    }
                    break;
                case 11:
                    {
                    // Event: ChargingStatusReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ChargingStatusReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ChargingStatusReqType(stream, &BodyType->ChargingStatusReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ChargingStatusReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingStatusReq>");
                    }
                    break;
                case 12:
                    {
                    // Event: ChargingStatusRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ChargingStatusRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ChargingStatusResType(stream, &BodyType->ChargingStatusRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ChargingStatusRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ChargingStatusRes>");
                    }
                    break;
                case 13:
                    {
                    // Event: CurrentDemandReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CurrentDemandReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CurrentDemandReqType(stream, &BodyType->CurrentDemandReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CurrentDemandReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CurrentDemandReq>");
                    }
                    break;
                case 14:
                    {
                    // Event: CurrentDemandRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}CurrentDemandRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_CurrentDemandResType(stream, &BodyType->CurrentDemandRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->CurrentDemandRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}CurrentDemandRes>");
                    }
                    break;
                case 15:
                    {
                    // Event: MeteringReceiptReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}MeteringReceiptReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_MeteringReceiptReqType(stream, &BodyType->MeteringReceiptReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->MeteringReceiptReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeteringReceiptReq>");
                    }
                    break;
                case 16:
                    {
                    // Event: MeteringReceiptRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}MeteringReceiptRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_MeteringReceiptResType(stream, &BodyType->MeteringReceiptRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->MeteringReceiptRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}MeteringReceiptRes>");
                    }
                    break;
                case 17:
                    {
                    // Event: PaymentDetailsReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PaymentDetailsReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PaymentDetailsReqType(stream, &BodyType->PaymentDetailsReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PaymentDetailsReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PaymentDetailsReq>");
                    }
                    break;
                case 18:
                    {
                    // Event: PaymentDetailsRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PaymentDetailsRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PaymentDetailsResType(stream, &BodyType->PaymentDetailsRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PaymentDetailsRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PaymentDetailsRes>");
                    }
                    break;
                case 19:
                    {
                    // Event: PaymentServiceSelectionReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PaymentServiceSelectionReqType(stream, &BodyType->PaymentServiceSelectionReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PaymentServiceSelectionReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionReq>");
                    }
                    break;
                case 20:
                    {
                    // Event: PaymentServiceSelectionRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PaymentServiceSelectionResType(stream, &BodyType->PaymentServiceSelectionRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PaymentServiceSelectionRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PaymentServiceSelectionRes>");
                    }
                    break;
                case 21:
                    {
                    // Event: PowerDeliveryReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PowerDeliveryReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PowerDeliveryReqType(stream, &BodyType->PowerDeliveryReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PowerDeliveryReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PowerDeliveryReq>");
                    }
                    break;
                case 22:
                    {
                    // Event: PowerDeliveryRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PowerDeliveryRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PowerDeliveryResType(stream, &BodyType->PowerDeliveryRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PowerDeliveryRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PowerDeliveryRes>");
                    }
                    break;
                case 23:
                    {
                    // Event: PreChargeReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PreChargeReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PreChargeReqType(stream, &BodyType->PreChargeReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PreChargeReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PreChargeReq>");
                    }
                    break;
                case 24:
                    {
                    // Event: PreChargeRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}PreChargeRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_PreChargeResType(stream, &BodyType->PreChargeRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->PreChargeRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}PreChargeRes>");
                    }
                    break;
                case 25:
                    {
                    // Event: ServiceDetailReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ServiceDetailReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ServiceDetailReqType(stream, &BodyType->ServiceDetailReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ServiceDetailReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceDetailReq>");
                    }
                    break;
                case 26:
                    {
                    // Event: ServiceDetailRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ServiceDetailRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ServiceDetailResType(stream, &BodyType->ServiceDetailRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ServiceDetailRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceDetailRes>");
                    }
                    break;
                case 27:
                    {
                    // Event: ServiceDiscoveryReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ServiceDiscoveryReqType(stream, &BodyType->ServiceDiscoveryReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ServiceDiscoveryReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryReq>");
                    }
                    break;
                case 28:
                    {
                    // Event: ServiceDiscoveryRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_ServiceDiscoveryResType(stream, &BodyType->ServiceDiscoveryRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->ServiceDiscoveryRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}ServiceDiscoveryRes>");
                    }
                    break;
                case 29:
                    {
                    // Event: SessionSetupReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}SessionSetupReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_SessionSetupReqType(stream, &BodyType->SessionSetupReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->SessionSetupReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionSetupReq>");
                    }
                    break;
                case 30:
                    {
                    // Event: SessionSetupRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}SessionSetupRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_SessionSetupResType(stream, &BodyType->SessionSetupRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->SessionSetupRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionSetupRes>");
                    }
                    break;
                case 31:
                    {
                    // Event: SessionStopReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}SessionStopReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_SessionStopReqType(stream, &BodyType->SessionStopReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->SessionStopReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionStopReq>");
                    }
                    break;
                case 32:
                    {
                    // Event: SessionStopRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}SessionStopRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_SessionStopResType(stream, &BodyType->SessionStopRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->SessionStopRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}SessionStopRes>");
                    }
                    break;
                case 33:
                    {
                    // Event: WeldingDetectionReq
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}WeldingDetectionReq");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_WeldingDetectionReqType(stream, &BodyType->WeldingDetectionReq, xmlOut);
                    if (error == 0)
                    {
                        BodyType->WeldingDetectionReq_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}WeldingDetectionReq>");
                    }
                    break;
                case 34:
                    {
                    // Event: WeldingDetectionRes
                    strcat(xmlOut, "><{urn:iso:15118:2:2013:MsgBody}WeldingDetectionRes");
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    // decode: namespace element
                    error = decode_iso2_WeldingDetectionResType(stream, &BodyType->WeldingDetectionRes, xmlOut);
                    if (error == 0)
                    {
                        BodyType->WeldingDetectionRes_isUsed = 1u;
                        grammar_id = 3;
                    }
                    bool isClosed = false;
                        while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgBody}WeldingDetectionRes>");
                    }
                    break;

                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;

        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:15118:2:2013:MsgDef}V2G_Message; type=AnonymousType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Header, MessageHeaderType (1, 1); Body, BodyType (1, 1);
static int decode_iso2_V2G_Message(exi_bitstream_t* stream, struct iso2_V2G_Message* V2G_Message, char* xmlOut) {
    int grammar_id = 463;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso2_V2G_Message(V2G_Message);

    while(!done)
    {
        switch(grammar_id)
        {
        case 463:
            // Grammar: ID=463; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=464

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDef}Header");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDef}Header");
                    // decode: element
                    error = decode_iso2_MessageHeaderType(stream, &V2G_Message->Header, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 464;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDef}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 464:
            // Grammar: ID=464; read/write bits=1; START (Body)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: START (Body, BodyType (BodyType)); next=3

                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDef}Body");
                    xmlPos += strlen("<{urn:iso:15118:2:2013:MsgDef}Body");
                    // decode: element
                    error = decode_iso2_BodyType(stream, &V2G_Message->Body, xmlOut);
                    if (error == 0)
                    {
                        grammar_id = 3;
                    }


                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDef}Body>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 3:
            // Grammar: ID=3; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch(eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=4
                    done = 1;
                    grammar_id = 4;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}


// main function for decoding
int decode_iso2_exiDocument(exi_bitstream_t* stream, struct iso2_exiDocument* exiDoc, char* xmlOut)
{
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso2_exiDocument(exiDoc);
        strcat(xmlOut, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        strcat(xmlOut, "<{urn:iso:15118:2:2013:MsgDef}V2G_Message>");
        error = exi_basetypes_decoder_nbit_uint(stream, 7, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            switch(eventCode)
            {
            case 0:
            case 76:
                error = decode_iso2_V2G_Message(stream, &exiDoc->V2G_Message, xmlOut);
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }
        }
    }
    strcat(xmlOut, "</{urn:iso:15118:2:2013:MsgDef}V2G_Message>");


    int FQN_FULL_LENGTH = 50;
    int FQN_SHORT_LENGTH = 5;
    // xmlOut Postprocessing: resolve FQNs
    char *prefixList[10][2]; // 10 prefixes max. [0]: shorthand, [1]:fqn
    int prefixCount = 0;
    char* currentXmlPtr = &xmlOut[0];
    size_t posOfPrefixStart;
    size_t prefixSize;
    // create prefix table
    while( (posOfPrefixStart = strcspn(currentXmlPtr, "{")) != strlen(currentXmlPtr) ) {
        currentXmlPtr += posOfPrefixStart + 1;
        prefixSize = strcspn(currentXmlPtr, "}");
        
        bool hit = false;
        // check if prefix already in list
        for(int i = 0; i < prefixCount; i++)
        {
            if(strncmp(prefixList[i][1], currentXmlPtr, prefixSize) == 0)
            {
                hit = true; break;
            }
        }
        if(!hit) {
            prefixList[prefixCount][0] = malloc(sizeof(*prefixList[prefixCount]) * FQN_SHORT_LENGTH);
            prefixList[prefixCount][1] = malloc(sizeof(*prefixList[prefixCount]) * FQN_FULL_LENGTH);
            strncpy(prefixList[prefixCount][1], currentXmlPtr, prefixSize);
            prefixList[prefixCount][1][prefixSize] = 0;
                sprintf(prefixList[prefixCount][0], "ns%d", prefixCount + 1);
                    prefixCount ++;
        }
        currentXmlPtr += prefixSize;
    }
    char* xmlDup = strdup(xmlOut);
    int elementCount = 0;
    int xmlOutLength = 0;
    for(size_t i = 0; i < strlen(xmlDup); i++)
    {
        if(xmlDup[i] == '{')
        {
            // handle prefix stuff
            i++; // skip '{'
            char fqn[FQN_FULL_LENGTH];
            memset(fqn, 0, FQN_FULL_LENGTH*sizeof(char) );
            for(int j = 0; j < FQN_FULL_LENGTH && i < strlen(xmlDup); j++)
            {
                if(xmlDup[i] == '}') { fqn[j] = 0; break; }
                else { fqn[j] = xmlDup[i]; }
                i++;
            }
            xmlOut[xmlOutLength] = 0;
            for(int k = 0; k < prefixCount; k++) {
                if (strcmp(fqn, prefixList[k][1]) == 0)
                {
                    strcat(xmlOut, prefixList[k][0]);
                    strcat(xmlOut, ":");
                    xmlOutLength += strlen(prefixList[k][0]) + 1;
                    break;
                }
            }
        }
        else
        {
            if(xmlDup[i] == '<') elementCount++;
            if(elementCount == 2 && xmlDup[i] == '>')
            {
                // root element, add namespaces here
                for(int j = 0; j < prefixCount; j++)
                {
                    xmlOut[xmlOutLength] = 0;
                    strcat(xmlOut, " xmlns:");
                    strcat(xmlOut, prefixList[j][0]);
                    strcat(xmlOut, "=\"");
                    strcat(xmlOut, prefixList[j][1]);
                    strcat(xmlOut, "\"");
                    xmlOutLength = strlen(xmlOut);
                }
            }
            xmlOut[xmlOutLength++] = xmlDup[i];
        }
    }
    xmlOut[xmlOutLength] = 0;
    
    // clean up
    for(int i = 0; i < prefixCount; i++)
    {
        free(prefixList[i][0]);
        free(prefixList[i][1]);
    }
    free(xmlDup);
    
    return error;
}

// main function for decoding fragment
/* NOTE! There may be problems when comparing the signature of the eMAID.
   In the ISO 15118-2 schema there are two different types with problematic names,
   EMAIDType and eMAIDType. The fragment de- and encoder of e.g. openV2G considers
   this type as generic type EXISchemaInformedElementFragmentGrammar. We treat it as a complex type.
   We have not yet been able to determine why this particular type has to be coded as a generic type,
   and only for the fragment decoder and encoder.
   This is why we have not yet adapted our fragment coders, and it can lead to the problem mentioned. */
int decode_iso2_exiFragment(exi_bitstream_t* stream, struct iso2_exiFragment* exiFrag, char* xmlOut) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso2_exiFragment(exiFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 8, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch(eventCode)
            {
            case 0:
                // AC_EVChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 1:
                // AC_EVSEChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 2:
                // AC_EVSEStatus (urn:iso:15118:2:2013:MsgBody)
                break;
            case 3:
                // AC_EVSEStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 4:
                // AuthorizationReq (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_AuthorizationReqType(stream, &exiFrag->AuthorizationReq, xmlOut);
                exiFrag->AuthorizationReq_isUsed = 1u;
                break;
            case 5:
                // AuthorizationRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 6:
                // Body (urn:iso:15118:2:2013:MsgDef)
                break;
            case 7:
                // BodyElement (urn:iso:15118:2:2013:MsgBody)
                break;
            case 8:
                // BulkChargingComplete (urn:iso:15118:2:2013:MsgBody)
                break;
            case 9:
                // BulkChargingComplete (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 10:
                // BulkSOC (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 11:
                // CableCheckReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 12:
                // CableCheckRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 13:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 14:
                // Certificate (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 15:
                // CertificateInstallationReq (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_CertificateInstallationReqType(stream, &exiFrag->CertificateInstallationReq, xmlOut);
                exiFrag->CertificateInstallationReq_isUsed = 1u;
                break;
            case 16:
                // CertificateInstallationRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 17:
                // CertificateUpdateReq (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_CertificateUpdateReqType(stream, &exiFrag->CertificateUpdateReq, xmlOut);
                exiFrag->CertificateUpdateReq_isUsed = 1u;
                break;
            case 18:
                // CertificateUpdateRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 19:
                // ChargeParameterDiscoveryReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 20:
                // ChargeParameterDiscoveryRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 21:
                // ChargeProgress (urn:iso:15118:2:2013:MsgBody)
                break;
            case 22:
                // ChargeService (urn:iso:15118:2:2013:MsgBody)
                break;
            case 23:
                // ChargingComplete (urn:iso:15118:2:2013:MsgBody)
                break;
            case 24:
                // ChargingComplete (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 25:
                // ChargingProfile (urn:iso:15118:2:2013:MsgBody)
                break;
            case 26:
                // ChargingProfileEntryMaxNumberOfPhasesInUse (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 27:
                // ChargingProfileEntryMaxPower (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 28:
                // ChargingProfileEntryStart (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 29:
                // ChargingSession (urn:iso:15118:2:2013:MsgBody)
                break;
            case 30:
                // ChargingStatusReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 31:
                // ChargingStatusRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 32:
                // ConsumptionCost (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 33:
                // ContractSignatureCertChain (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_CertificateChainType(stream, &exiFrag->ContractSignatureCertChain, xmlOut);
                exiFrag->ContractSignatureCertChain_isUsed = 1u;
                break;
            case 34:
                // ContractSignatureEncryptedPrivateKey (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_ContractSignatureEncryptedPrivateKeyType(stream, &exiFrag->ContractSignatureEncryptedPrivateKey, xmlOut);
                exiFrag->ContractSignatureEncryptedPrivateKey_isUsed = 1u;
                break;
            case 35:
                // Cost (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 36:
                // CurrentDemandReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 37:
                // CurrentDemandRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 38:
                // DC_EVChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 39:
                // DC_EVPowerDeliveryParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 40:
                // DC_EVSEChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 41:
                // DC_EVSEStatus (urn:iso:15118:2:2013:MsgBody)
                break;
            case 42:
                // DC_EVSEStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 43:
                // DC_EVStatus (urn:iso:15118:2:2013:MsgBody)
                break;
            case 44:
                // DC_EVStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 45:
                // DHpublickey (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_DiffieHellmanPublickeyType(stream, &exiFrag->DHpublickey, xmlOut);
                exiFrag->DHpublickey_isUsed = 1u;
                break;
            case 46:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 47:
                // DepartureTime (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 48:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 49:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 50:
                // EAmount (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 51:
                // EPriceLevel (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 52:
                // EVCCID (urn:iso:15118:2:2013:MsgBody)
                break;
            case 53:
                // EVChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 54:
                // EVEnergyCapacity (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 55:
                // EVEnergyRequest (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 56:
                // EVErrorCode (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 57:
                // EVMaxCurrent (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 58:
                // EVMaxVoltage (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 59:
                // EVMaximumCurrentLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 60:
                // EVMaximumCurrentLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 61:
                // EVMaximumPowerLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 62:
                // EVMaximumPowerLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 63:
                // EVMaximumVoltageLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 64:
                // EVMaximumVoltageLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 65:
                // EVMinCurrent (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 66:
                // EVPowerDeliveryParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 67:
                // EVRESSSOC (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 68:
                // EVReady (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 69:
                // EVSEChargeParameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 70:
                // EVSECurrentLimitAchieved (urn:iso:15118:2:2013:MsgBody)
                break;
            case 71:
                // EVSECurrentRegulationTolerance (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 72:
                // EVSEEnergyToBeDelivered (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 73:
                // EVSEID (urn:iso:15118:2:2013:MsgBody)
                break;
            case 74:
                // EVSEIsolationStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 75:
                // EVSEMaxCurrent (urn:iso:15118:2:2013:MsgBody)
                break;
            case 76:
                // EVSEMaxCurrent (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 77:
                // EVSEMaximumCurrentLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 78:
                // EVSEMaximumCurrentLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 79:
                // EVSEMaximumPowerLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 80:
                // EVSEMaximumPowerLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 81:
                // EVSEMaximumVoltageLimit (urn:iso:15118:2:2013:MsgBody)
                break;
            case 82:
                // EVSEMaximumVoltageLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 83:
                // EVSEMinimumCurrentLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 84:
                // EVSEMinimumVoltageLimit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 85:
                // EVSENominalVoltage (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 86:
                // EVSENotification (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 87:
                // EVSEPeakCurrentRipple (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 88:
                // EVSEPowerLimitAchieved (urn:iso:15118:2:2013:MsgBody)
                break;
            case 89:
                // EVSEPresentCurrent (urn:iso:15118:2:2013:MsgBody)
                break;
            case 90:
                // EVSEPresentVoltage (urn:iso:15118:2:2013:MsgBody)
                break;
            case 91:
                // EVSEProcessing (urn:iso:15118:2:2013:MsgBody)
                break;
            case 92:
                // EVSEStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 93:
                // EVSEStatusCode (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 94:
                // EVSETimeStamp (urn:iso:15118:2:2013:MsgBody)
                break;
            case 95:
                // EVSEVoltageLimitAchieved (urn:iso:15118:2:2013:MsgBody)
                break;
            case 96:
                // EVStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 97:
                // EVTargetCurrent (urn:iso:15118:2:2013:MsgBody)
                break;
            case 98:
                // EVTargetVoltage (urn:iso:15118:2:2013:MsgBody)
                break;
            case 99:
                // EnergyTransferMode (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 100:
                // Entry (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 101:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 102:
                // FaultCode (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 103:
                // FaultMsg (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 104:
                // FreeService (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 105:
                // FullSOC (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 106:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 107:
                // GenChallenge (urn:iso:15118:2:2013:MsgBody)
                break;
            case 108:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 109:
                // Header (urn:iso:15118:2:2013:MsgDef)
                break;
            case 110:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 111:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 112:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 113:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 114:
                // ListOfRootCertificateIDs (urn:iso:15118:2:2013:MsgBody)
                break;
            case 115:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 116:
                // MaxEntriesSAScheduleTuple (urn:iso:15118:2:2013:MsgBody)
                break;
            case 117:
                // MeterID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 118:
                // MeterInfo (urn:iso:15118:2:2013:MsgBody)
                break;
            case 119:
                // MeterReading (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 120:
                // MeterStatus (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 121:
                // MeteringReceiptReq (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_MeteringReceiptReqType(stream, &exiFrag->MeteringReceiptReq, xmlOut);
                exiFrag->MeteringReceiptReq_isUsed = 1u;
                break;
            case 122:
                // MeteringReceiptRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 123:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 124:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 125:
                // Multiplier (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 126:
                // Notification (urn:iso:15118:2:2013:MsgHeader)
                break;
            case 127:
                // NotificationMaxDelay (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 128:
                // NumEPriceLevels (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 129:
                // OEMProvisioningCert (urn:iso:15118:2:2013:MsgBody)
                break;
            case 130:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 131:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 132:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 133:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 134:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 135:
                // PMax (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 136:
                // PMaxSchedule (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 137:
                // PMaxScheduleEntry (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 138:
                // Parameter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 139:
                // ParameterSet (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 140:
                // ParameterSetID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 141:
                // PaymentDetailsReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 142:
                // PaymentDetailsRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 143:
                // PaymentOption (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 144:
                // PaymentOptionList (urn:iso:15118:2:2013:MsgBody)
                break;
            case 145:
                // PaymentServiceSelectionReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 146:
                // PaymentServiceSelectionRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 147:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 148:
                // PowerDeliveryReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 149:
                // PowerDeliveryRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 150:
                // PreChargeReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 151:
                // PreChargeRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 152:
                // ProfileEntry (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 153:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 154:
                // RCD (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 155:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 156:
                // ReceiptRequired (urn:iso:15118:2:2013:MsgBody)
                break;
            case 157:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 158:
                // RelativeTimeInterval (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 159:
                // RemainingTimeToBulkSoC (urn:iso:15118:2:2013:MsgBody)
                break;
            case 160:
                // RemainingTimeToFullSoC (urn:iso:15118:2:2013:MsgBody)
                break;
            case 161:
                // RequestedEnergyTransferMode (urn:iso:15118:2:2013:MsgBody)
                break;
            case 162:
                // ResponseCode (urn:iso:15118:2:2013:MsgBody)
                break;
            case 163:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 164:
                // RetryCounter (urn:iso:15118:2:2013:MsgBody)
                break;
            case 165:
                // RootCertificateID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 166:
                // SAProvisioningCertificateChain (urn:iso:15118:2:2013:MsgBody)
                break;
            case 167:
                // SAScheduleList (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 168:
                // SAScheduleTuple (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 169:
                // SAScheduleTupleID (urn:iso:15118:2:2013:MsgBody)
                break;
            case 170:
                // SAScheduleTupleID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 171:
                // SASchedules (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 172:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 173:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 174:
                // SalesTariff (urn:iso:15118:2:2013:MsgDataTypes)
                error = decode_iso2_SalesTariffType(stream, &exiFrag->SalesTariff, xmlOut);
                exiFrag->SalesTariff_isUsed = 1u;
                break;
            case 175:
                // SalesTariffDescription (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 176:
                // SalesTariffEntry (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 177:
                // SalesTariffID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 178:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 179:
                // SelectedPaymentOption (urn:iso:15118:2:2013:MsgBody)
                break;
            case 180:
                // SelectedService (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 181:
                // SelectedServiceList (urn:iso:15118:2:2013:MsgBody)
                break;
            case 182:
                // Service (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 183:
                // ServiceCategory (urn:iso:15118:2:2013:MsgBody)
                break;
            case 184:
                // ServiceCategory (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 185:
                // ServiceDetailReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 186:
                // ServiceDetailRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 187:
                // ServiceDiscoveryReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 188:
                // ServiceDiscoveryRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 189:
                // ServiceID (urn:iso:15118:2:2013:MsgBody)
                break;
            case 190:
                // ServiceID (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 191:
                // ServiceList (urn:iso:15118:2:2013:MsgBody)
                break;
            case 192:
                // ServiceName (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 193:
                // ServiceParameterList (urn:iso:15118:2:2013:MsgBody)
                break;
            case 194:
                // ServiceScope (urn:iso:15118:2:2013:MsgBody)
                break;
            case 195:
                // ServiceScope (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 196:
                // SessionID (urn:iso:15118:2:2013:MsgBody)
                break;
            case 197:
                // SessionID (urn:iso:15118:2:2013:MsgHeader)
                break;
            case 198:
                // SessionSetupReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 199:
                // SessionSetupRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 200:
                // SessionStopReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 201:
                // SessionStopRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 202:
                // SigMeterReading (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 203:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 204:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 205:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 206:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 207:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 208:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SignedInfoType(stream, &exiFrag->SignedInfo, xmlOut);
                exiFrag->SignedInfo_isUsed = 1u;
                break;
            case 209:
                // SubCertificates (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 210:
                // SupportedEnergyTransferMode (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 211:
                // TMeter (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 212:
                // TimeInterval (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 213:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 214:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 215:
                // Unit (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 216:
                // V2G_Message (urn:iso:15118:2:2013:MsgDef)
                break;
            case 217:
                // Value (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 218:
                // WeldingDetectionReq (urn:iso:15118:2:2013:MsgBody)
                break;
            case 219:
                // WeldingDetectionRes (urn:iso:15118:2:2013:MsgBody)
                break;
            case 220:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 221:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 222:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 223:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 224:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 225:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 226:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 227:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 228:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 229:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 230:
                // amount (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 231:
                // amountMultiplier (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 232:
                // boolValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 233:
                // byteValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 234:
                // costKind (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 235:
                // duration (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 236:
                // eMAID (urn:iso:15118:2:2013:MsgBody)
                error = decode_iso2_EMAIDType(stream, &exiFrag->eMAID, xmlOut);
                exiFrag->eMAID_isUsed = 1u;
                break;
            case 237:
                // intValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 238:
                // physicalValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 239:
                // shortValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 240:
                // start (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 241:
                // startValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            case 242:
                // stringValue (urn:iso:15118:2:2013:MsgDataTypes)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 8, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 244)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}

// main function for decoding xmldsig fragment
int decode_iso2_xmldsigFragment(exi_bitstream_t* stream, struct iso2_xmldsigFragment* xmldsigFrag, char* xmlOut) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso2_xmldsigFragment(xmldsigFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch(eventCode)
            {
            case 0:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_CanonicalizationMethodType(stream, &xmldsigFrag->CanonicalizationMethod, xmlOut);
                xmldsigFrag->CanonicalizationMethod_isUsed = 1u;
                break;
            case 1:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_DSAKeyValueType(stream, &xmldsigFrag->DSAKeyValue, xmlOut);
                xmldsigFrag->DSAKeyValue_isUsed = 1u;
                break;
            case 2:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_DigestMethodType(stream, &xmldsigFrag->DigestMethod, xmlOut);
                xmldsigFrag->DigestMethod_isUsed = 1u;
                break;
            case 3:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 4:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 5:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 6:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 7:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 8:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_KeyInfoType(stream, &xmldsigFrag->KeyInfo, xmlOut);
                xmldsigFrag->KeyInfo_isUsed = 1u;
                break;
            case 9:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 10:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_KeyValueType(stream, &xmldsigFrag->KeyValue, xmlOut);
                xmldsigFrag->KeyValue_isUsed = 1u;
                break;
            case 11:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 12:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 13:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 14:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_ObjectType(stream, &xmldsigFrag->Object, xmlOut);
                xmldsigFrag->Object_isUsed = 1u;
                break;
            case 15:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 16:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_PGPDataType(stream, &xmldsigFrag->PGPData, xmlOut);
                xmldsigFrag->PGPData_isUsed = 1u;
                break;
            case 17:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 18:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 19:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 20:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 21:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_RSAKeyValueType(stream, &xmldsigFrag->RSAKeyValue, xmlOut);
                xmldsigFrag->RSAKeyValue_isUsed = 1u;
                break;
            case 22:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_ReferenceType(stream, &xmldsigFrag->Reference, xmlOut);
                xmldsigFrag->Reference_isUsed = 1u;
                break;
            case 23:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_RetrievalMethodType(stream, &xmldsigFrag->RetrievalMethod, xmlOut);
                xmldsigFrag->RetrievalMethod_isUsed = 1u;
                break;
            case 24:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SPKIDataType(stream, &xmldsigFrag->SPKIData, xmlOut);
                xmldsigFrag->SPKIData_isUsed = 1u;
                break;
            case 25:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 26:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 27:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SignatureType(stream, &xmldsigFrag->Signature, xmlOut);
                xmldsigFrag->Signature_isUsed = 1u;
                break;
            case 28:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SignatureMethodType(stream, &xmldsigFrag->SignatureMethod, xmlOut);
                xmldsigFrag->SignatureMethod_isUsed = 1u;
                break;
            case 29:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 30:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 31:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SignatureValueType(stream, &xmldsigFrag->SignatureValue, xmlOut);
                xmldsigFrag->SignatureValue_isUsed = 1u;
                break;
            case 32:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_SignedInfoType(stream, &xmldsigFrag->SignedInfo, xmlOut);
                xmldsigFrag->SignedInfo_isUsed = 1u;
                break;
            case 33:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_TransformType(stream, &xmldsigFrag->Transform, xmlOut);
                xmldsigFrag->Transform_isUsed = 1u;
                break;
            case 34:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_TransformsType(stream, &xmldsigFrag->Transforms, xmlOut);
                xmldsigFrag->Transforms_isUsed = 1u;
                break;
            case 35:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 36:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 37:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_X509DataType(stream, &xmldsigFrag->X509Data, xmlOut);
                xmldsigFrag->X509Data_isUsed = 1u;
                break;
            case 38:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 39:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso2_X509IssuerSerialType(stream, &xmldsigFrag->X509IssuerSerial, xmlOut);
                xmldsigFrag->X509IssuerSerial_isUsed = 1u;
                break;
            case 40:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 41:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 42:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 43:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 44:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 46)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}


